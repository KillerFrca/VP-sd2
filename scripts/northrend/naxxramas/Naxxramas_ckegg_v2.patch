Index: boss_anubrekhan.cpp
===================================================================
--- boss_anubrekhan.cpp	(revision 1388)
+++ boss_anubrekhan.cpp	(working copy)
@@ -22,6 +22,7 @@
 EndScriptData */
 
 #include "precompiled.h"
+#include "def_naxxramas.h"
 
 enum
 {
@@ -39,6 +40,7 @@
     SPELL_IMPALE_H              = 56090,
     SPELL_LOCUSTSWARM           = 28785,                    //This is a self buff that triggers the dmg debuff
     SPELL_LOCUSTSWARM_H         = 54021,
+    SPELL_BERSERK               = 26662,
 
     //spellId invalid
     SPELL_SUMMONGUARD           = 29508,                    //Summons 1 crypt guard at targeted location
@@ -46,7 +48,11 @@
     SPELL_SELF_SPAWN_5          = 29105,                    //This spawns 5 corpse scarabs ontop of us (most likely the pPlayer casts this on death)
     SPELL_SELF_SPAWN_10         = 28864,                    //This is used by the crypt guards when they die
 
-    NPC_CRYPT_GUARD             = 16573
+    NPC_CRYPT_GUARD             = 16573,
+    SPELL_ACID_SPIT             = 28969,
+    SPELL_ACID_SPIT_H           = 56098,
+    SPELL_CLEAVE                = 40504,
+    SPELL_FRENZY                = 8269
 };
 
 struct MANGOS_DLL_DECL boss_anubrekhanAI : public ScriptedAI
@@ -65,13 +71,26 @@
     uint32 Impale_Timer;
     uint32 LocustSwarm_Timer;
     uint32 Summon_Timer;
+    uint32 Berserk_Timer;
+
+    std::list<uint64> m_lCryptGuardList;
+
+    uint64 CryptGuardGUID[2];
     bool HasTaunted;
 
     void Reset()
     {
         Impale_Timer = 15000;                               //15 seconds
         LocustSwarm_Timer = 80000 + (rand()%40000);         //Random time between 80 seconds and 2 minutes for initial cast
-        Summon_Timer = LocustSwarm_Timer + 45000;           //45 seconds after initial locust swarm
+        Summon_Timer = LocustSwarm_Timer + 20000;           //45 seconds after initial locust swarm
+        Berserk_Timer = 300000;
+
+        DespawnGuard();
+        for(uint8 i = 0; i < (m_bIsHeroicMode ? 2 : 1); i++)
+            m_creature->SummonCreature(NPC_CRYPT_GUARD, m_creature->GetPositionX(), m_creature->GetPositionY()+10, m_creature->GetPositionZ(), m_creature->GetOrientation(), TEMPSUMMON_CORPSE_TIMED_DESPAWN, 300000);
+
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_ANUB_REKHAN, NOT_STARTED);
     }
 
     void KilledUnit(Unit* pVictim)
@@ -86,6 +105,12 @@
         DoScriptText(SAY_SLAY, m_creature);
     }
 
+    void JustDied(Unit* Killer)
+    {
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_ANUB_REKHAN, DONE);
+    }
+
     void Aggro(Unit *who)
     {
         switch(rand()%3)
@@ -94,6 +119,21 @@
             case 1: DoScriptText(SAY_AGGRO2, m_creature); break;
             case 2: DoScriptText(SAY_AGGRO3, m_creature); break;
         }
+
+        if (m_pInstance)
+        {
+            m_pInstance->SetData(TYPE_ANUB_REKHAN, IN_PROGRESS);
+
+            for(uint8 i = 0; i < (m_bIsHeroicMode ? 2 : 1); i++)
+            {
+                if (Creature* pCryptGuard = ((Creature*)Unit::GetUnit((*m_creature), CryptGuardGUID[i])))
+                    if (pCryptGuard->isAlive())
+                    {
+                        pCryptGuard->AddThreat(who,0.0f);
+                        pCryptGuard->AI()->AttackStart(who);
+                    }
+            }
+        }
     }
 
     void MoveInLineOfSight(Unit *who)
@@ -114,11 +154,41 @@
         ScriptedAI::MoveInLineOfSight(who);
     }
 
+    void DespawnGuard()
+    {
+        if (m_lCryptGuardList.empty())
+            return;
+
+        for(std::list<uint64>::iterator itr = m_lCryptGuardList.begin(); itr != m_lCryptGuardList.end(); ++itr)
+        {
+            if (Creature* pTemp = (Creature*)Unit::GetUnit(*m_creature, *itr))
+            {
+                if (pTemp->isAlive())
+                    pTemp->ForcedDespawn();
+            }
+        }
+
+        m_lCryptGuardList.clear();
+    }
+
+    void JustSummoned(Creature* pSummoned)
+    {
+        if (pSummoned->GetEntry() == NPC_CRYPT_GUARD)
+            m_lCryptGuardList.push_back(pSummoned->GetGUID());
+    }
+
     void UpdateAI(const uint32 diff)
     {
         if (!m_creature->SelectHostilTarget() || !m_creature->getVictim())
             return;
 
+        if (Berserk_Timer)
+            if (Berserk_Timer < diff)
+            {
+                DoCast(m_creature, SPELL_BERSERK);
+                Berserk_Timer = 0;
+            }else Berserk_Timer -= diff;
+
         //Impale_Timer
         if (Impale_Timer < diff)
         {
@@ -137,25 +207,116 @@
         if (LocustSwarm_Timer < diff)
         {
             DoCast(m_creature, m_bIsHeroicMode ? SPELL_LOCUSTSWARM_H : SPELL_LOCUSTSWARM);
-            LocustSwarm_Timer = 90000;
+            if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
+                if (Creature* pTemp = m_creature->SummonCreature(NPC_CRYPT_GUARD, pTarget->GetPositionX(), pTarget->GetPositionY(), pTarget->GetPositionZ(), 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 30000))
+                {
+                    pTemp->AddThreat(pTarget, 0.0f);
+                    pTemp->AI()->AttackStart(pTarget);
+                }
+            LocustSwarm_Timer = 90000 + (rand()%30000);
+            Summon_Timer += 30000;
         }else LocustSwarm_Timer -= diff;
 
         //Summon_Timer
-        /*if (Summon_Timer < diff)
+        if (Summon_Timer < diff)
         {
-            DoCast(m_creature, SPELL_SUMMONGUARD);
-            Summon_Timer = 45000;
-        }else Summon_Timer -= diff;*/
+            //DoCast(m_creature, SPELL_SUMMONGUARD);
+            if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
+                if (Creature* pTemp = m_creature->SummonCreature(NPC_CRYPT_GUARD, pTarget->GetPositionX(), pTarget->GetPositionY(), pTarget->GetPositionZ(), 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 30000))
+                {
+                    pTemp->AddThreat(pTarget, 0.0f);
+                    pTemp->AI()->AttackStart(pTarget);
+                }
+            Summon_Timer = 30000;
+        }else Summon_Timer -= diff;
 
         DoMeleeAttackIfReady();
     }
 };
 
+struct MANGOS_DLL_DECL mob_crypt_guardAI : public ScriptedAI
+{
+    mob_crypt_guardAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsHeroicMode = pCreature->GetMap()->IsHeroic();
+        Reset();
+    }
+
+    ScriptedInstance* m_pInstance;
+    bool m_bIsHeroicMode;
+
+    uint32 AcidSpit_Timer;
+    uint32 Cleave_Timer;
+    uint32 Berserk_Timer;
+
+    void Reset()
+    {
+        AcidSpit_Timer = 10000 + rand()%1000;
+        Cleave_Timer = 5000 + rand()%5000;
+        Berserk_Timer = 120000;
+    }
+
+    void KilledUnit(Unit* pVictim)
+    {
+        //Force the player to spawn corpse scarabs via spell
+        if (pVictim->GetTypeId() == TYPEID_PLAYER)
+            pVictim->CastSpell(pVictim, SPELL_SELF_SPAWN_5, true);
+    }
+
+    void JustDied(Unit* Killer)
+    {
+        m_creature->CastSpell(m_creature, SPELL_SELF_SPAWN_10, true);
+    }
+
+    void Aggro(Unit *who)
+    {
+        if (m_pInstance)
+        {
+            if (Creature* pAnubRekhan = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_ANUB_REKHAN))))
+                if (pAnubRekhan->isAlive() && !pAnubRekhan->getVictim())
+                    pAnubRekhan->AI()->AttackStart(who);
+        }
+    }
+
+    void UpdateAI(const uint32 diff)
+    {
+        if (!m_creature->SelectHostilTarget() || !m_creature->getVictim())
+            return;
+
+        if (Berserk_Timer)
+            if (Berserk_Timer < diff)
+            {
+                DoCast(m_creature, SPELL_FRENZY);
+                Berserk_Timer = 0;
+            }else Berserk_Timer -= diff;
+
+        if (AcidSpit_Timer < diff)
+        {
+            DoCast(m_creature->getVictim(), m_bIsHeroicMode ? SPELL_ACID_SPIT_H : SPELL_ACID_SPIT);
+            AcidSpit_Timer = 10000 + rand()%1000;
+        }else AcidSpit_Timer -= diff;
+
+        if (Cleave_Timer < diff)
+        {
+            DoCast(m_creature->getVictim(), SPELL_CLEAVE);
+            Cleave_Timer = 5000 + rand()%5000;
+        }else Cleave_Timer -= diff;
+
+        DoMeleeAttackIfReady();
+    }
+};
+
 CreatureAI* GetAI_boss_anubrekhan(Creature* pCreature)
 {
     return new boss_anubrekhanAI(pCreature);
 }
 
+CreatureAI* GetAI_mob_crypt_guard(Creature* pCreature)
+{
+    return new mob_crypt_guardAI(pCreature);
+}
+
 void AddSC_boss_anubrekhan()
 {
     Script *newscript;
@@ -163,4 +324,9 @@
     newscript->Name = "boss_anubrekhan";
     newscript->GetAI = &GetAI_boss_anubrekhan;
     newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "mob_crypt_guard";
+    newscript->GetAI = &GetAI_mob_crypt_guard;
+    newscript->RegisterSelf();
 }
Index: boss_faerlina.cpp
===================================================================
--- boss_faerlina.cpp	(revision 1388)
+++ boss_faerlina.cpp	(working copy)
@@ -22,6 +22,7 @@
 EndScriptData */
 
 #include "precompiled.h"
+#include "def_naxxramas.h"
 
 #define SAY_GREET                   -1533009
 #define SAY_AGGRO1                  -1533010
@@ -39,12 +40,24 @@
 #define SPELL_ENRAGE                28798
 #define H_SPELL_ENRAGE              54100
 
+#define SPELL_FIREBALL              54095
+#define SPELL_FIREBALL_H            54096
+#define SPELL_WIDOWS_EMBRACE        28732
+
 #define SPELL_RAINOFFIRE            28794                   //Not sure if targeted AoEs work if casted directly upon a pPlayer
 
 struct MANGOS_DLL_DECL boss_faerlinaAI : public ScriptedAI
 {
-    boss_faerlinaAI(Creature* pCreature) : ScriptedAI(pCreature) {Reset();}
+    boss_faerlinaAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsHeroicMode = pCreature->GetMap()->IsHeroic();
+        Reset();
+    }
 
+    ScriptedInstance* m_pInstance;
+    bool m_bIsHeroicMode;
+
     uint32 PoisonBoltVolley_Timer;
     uint32 RainOfFire_Timer;
     uint32 Enrage_Timer;
@@ -56,6 +69,18 @@
         RainOfFire_Timer = 16000;
         Enrage_Timer = 60000;
         HasTaunted = false;
+
+        std::list<Creature*> lUnitList;
+        GetCreatureListWithEntryInGrid(lUnitList, m_creature, 16506, 100.0f);
+        if (!lUnitList.empty())
+        {
+            for(std::list<Creature*>::iterator iter = lUnitList.begin(); iter != lUnitList.end(); ++iter)
+                if ((*iter)->isDead())
+                    (*iter)->Respawn();
+        }
+
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_FAERLINA, NOT_STARTED);
     }
 
     void Aggro(Unit *who)
@@ -67,6 +92,9 @@
             case 2: DoScriptText(SAY_AGGRO3, m_creature); break;
             case 3: DoScriptText(SAY_AGGRO4, m_creature); break;
         }
+
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_FAERLINA, IN_PROGRESS);
     }
 
     void MoveInLineOfSight(Unit *who)
@@ -92,6 +120,9 @@
     void JustDied(Unit* Killer)
     {
         DoScriptText(SAY_DEATH, m_creature);
+
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_FAERLINA, DONE);
     }
 
     void UpdateAI(const uint32 diff)
@@ -102,8 +133,8 @@
         //PoisonBoltVolley_Timer
         if (PoisonBoltVolley_Timer < diff)
         {
-            DoCast(m_creature->getVictim(),SPELL_POSIONBOLT_VOLLEY);
-            PoisonBoltVolley_Timer = 11000;
+            DoCast(m_creature->getVictim(), m_bIsHeroicMode ? H_SPELL_POSIONBOLT_VOLLEY : SPELL_POSIONBOLT_VOLLEY);
+            PoisonBoltVolley_Timer = 9000 + rand()%2000;
         }else PoisonBoltVolley_Timer -= diff;
 
         //RainOfFire_Timer
@@ -112,20 +143,103 @@
             if (Unit* target = SelectUnit(SELECT_TARGET_RANDOM,0))
                 DoCast(target,SPELL_RAINOFFIRE);
 
-            RainOfFire_Timer = 16000;
+            RainOfFire_Timer = 14000 + rand()%2000;
         }else RainOfFire_Timer -= diff;
 
         //Enrage_Timer
         if (Enrage_Timer < diff)
         {
-            DoCast(m_creature,SPELL_ENRAGE);
-            Enrage_Timer = 61000;
+            DoCast(m_creature, m_bIsHeroicMode ? H_SPELL_ENRAGE : SPELL_ENRAGE);
+            Enrage_Timer = 60000 + rand()%20000;
         }else Enrage_Timer -= diff;
 
         DoMeleeAttackIfReady();
     }
 };
 
+struct MANGOS_DLL_DECL mob_worshippersAI : public ScriptedAI
+{
+    mob_worshippersAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsHeroicMode = pCreature->GetMap()->IsHeroic();
+        Reset();
+    }
+
+    ScriptedInstance* m_pInstance;
+    bool m_bIsHeroicMode;
+    bool m_bIsDead;
+
+    uint32 m_uiFireball_Timer;
+    uint32 m_uiDeathDelay_Timer;
+
+    void Reset()
+    {
+        m_bIsDead = false;
+        m_uiFireball_Timer = 0;
+        m_uiDeathDelay_Timer = 0;
+    }
+
+    void DamageTaken(Unit* pDoneBy, uint32 &uiDamage)
+    {
+        if (m_bIsDead)
+        {
+            uiDamage = 0;
+            return;
+        }
+
+        if (uiDamage > m_creature->GetHealth())
+        {
+            if (m_creature->IsNonMeleeSpellCasted(false))
+                m_creature->InterruptNonMeleeSpells(false);
+
+            m_creature->RemoveAllAuras();
+            m_creature->AttackStop();
+
+            DoCast(m_creature, SPELL_WIDOWS_EMBRACE);
+
+            if (m_pInstance)
+                if (Creature* pFaerlina = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_FAERLINA))))
+                    if (m_creature->GetDistance2d(pFaerlina) <= 5 && pFaerlina->HasAura(m_bIsHeroicMode ? H_SPELL_ENRAGE : SPELL_ENRAGE))
+                        pFaerlina->RemoveAurasDueToSpell(m_bIsHeroicMode ? H_SPELL_ENRAGE : SPELL_ENRAGE);
+
+            m_bIsDead = true;
+            m_uiDeathDelay_Timer = 500;
+
+            uiDamage = 0;
+            return;
+        }
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        if (m_uiDeathDelay_Timer)
+            if (m_uiDeathDelay_Timer < uiDiff)
+            {
+                m_creature->DealDamage(m_creature, m_creature->GetHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+                m_uiDeathDelay_Timer = 0;
+            }
+            else m_uiDeathDelay_Timer -= uiDiff;
+
+        if (!m_creature->SelectHostilTarget() || !m_creature->getVictim() || m_bIsDead)
+            return;
+
+        if (m_uiFireball_Timer < uiDiff)
+        {
+            DoCast(m_creature->getVictim(), m_bIsHeroicMode ? SPELL_FIREBALL_H : SPELL_FIREBALL);
+            m_uiFireball_Timer = 7000 + rand()%4000;
+        }
+        else m_uiFireball_Timer -= uiDiff;
+
+        DoMeleeAttackIfReady();
+    }
+};
+
+CreatureAI* GetAI_mob_worshippers(Creature* pCreature)
+{
+    return new mob_worshippersAI(pCreature);
+}
+
 CreatureAI* GetAI_boss_faerlina(Creature* pCreature)
 {
     return new boss_faerlinaAI(pCreature);
@@ -138,4 +252,9 @@
     newscript->Name = "boss_faerlina";
     newscript->GetAI = &GetAI_boss_faerlina;
     newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "mob_worshippers";
+    newscript->GetAI = &GetAI_mob_worshippers;
+    newscript->RegisterSelf();
 }
Index: boss_four_horsemen.cpp
===================================================================
--- boss_four_horsemen.cpp	(revision 1388)
+++ boss_four_horsemen.cpp	(working copy)
@@ -22,6 +22,7 @@
 EndScriptData */
 
 #include "precompiled.h"
+#include "def_naxxramas.h"
 
 //all horsemen
 #define SPELL_SHIELDWALL            29061
@@ -47,10 +48,19 @@
 
 struct MANGOS_DLL_DECL boss_lady_blaumeuxAI : public ScriptedAI
 {
-    boss_lady_blaumeuxAI(Creature* pCreature) : ScriptedAI(pCreature) {Reset();}
+    boss_lady_blaumeuxAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsHeroicMode = pCreature->GetMap()->IsHeroic();
+        Reset();
+    }
 
+    ScriptedInstance* m_pInstance;
+    bool m_bIsHeroicMode;
+
     uint32 Mark_Timer;
     uint32 VoidZone_Timer;
+    uint32 ShadowBolt_Timer;
     bool ShieldWall1;
     bool ShieldWall2;
 
@@ -58,13 +68,32 @@
     {
         Mark_Timer = 20000;                                 // First Horsemen Mark is applied at 20 sec.
         VoidZone_Timer = 12000;                             // right
+        ShadowBolt_Timer = 5000;
         ShieldWall1 = true;
         ShieldWall2 = true;
+
+        if (m_pInstance)
+        {
+            m_pInstance->SetData(TYPE_FOUR_HORSEMEN, NOT_STARTED);
+
+            if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_KORTHAZZ))))
+                if (!pTemp->isAlive())
+                    pTemp->Respawn();
+            if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_RIVENDARE))))
+                if (!pTemp->isAlive())
+                    pTemp->Respawn();
+            if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_ZELIEK))))
+                if (!pTemp->isAlive())
+                    pTemp->Respawn();
+        }
     }
 
     void Aggro(Unit *who)
     {
         DoScriptText(SAY_BLAU_AGGRO, m_creature);
+
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_FOUR_HORSEMEN, IN_PROGRESS);
     }
 
     void KilledUnit(Unit* Victim)
@@ -75,6 +104,23 @@
     void JustDied(Unit* Killer)
     {
         DoScriptText(SAY_BLAU_DEATH, m_creature);
+
+        if (m_pInstance)
+        {
+            bool HorsemenDead = true;
+            if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_KORTHAZZ))))
+                if (pTemp->isAlive())
+                    HorsemenDead = false;
+            if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_RIVENDARE))))
+                if (pTemp->isAlive())
+                    HorsemenDead = false;
+            if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_ZELIEK))))
+                if (pTemp->isAlive())
+                    HorsemenDead = false;
+
+            if (HorsemenDead)
+                m_pInstance->SetData(TYPE_FOUR_HORSEMEN, DONE);
+        }
     }
 
     void UpdateAI(const uint32 diff)
@@ -107,10 +153,16 @@
             }
         }
 
+        if (ShadowBolt_Timer < diff)
+        {
+            DoCast(m_creature->getVictim(), m_bIsHeroicMode ? H_SPELL_SHADOW_BOLT : SPELL_SHADOW_BOLT);
+            ShadowBolt_Timer = 12000;
+        }else ShadowBolt_Timer -= diff;
+
         // Void Zone
         if (VoidZone_Timer < diff)
         {
-            DoCast(m_creature->getVictim(),SPELL_VOIDZONE);
+            DoCast(m_creature->getVictim(), m_bIsHeroicMode ? H_SPELL_VOIDZONE : SPELL_VOIDZONE);
             VoidZone_Timer = 12000;
         }else VoidZone_Timer -= diff;
 
@@ -143,10 +195,42 @@
 
 struct MANGOS_DLL_DECL boss_rivendare_naxxAI : public ScriptedAI
 {
-    boss_rivendare_naxxAI(Creature* pCreature) : ScriptedAI(pCreature) {Reset();}
+    boss_rivendare_naxxAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsHeroicMode = pCreature->GetMap()->IsHeroic();
+        Reset();
+    }
 
+    ScriptedInstance* m_pInstance;
+    bool m_bIsHeroicMode;
+
+    uint32 Mark_Timer;
+    uint32 UnholyShadow_Timer;
+    bool ShieldWall1;
+    bool ShieldWall2;
+
     void Reset()
     {
+        Mark_Timer = 20000;
+        UnholyShadow_Timer = 15000;
+        ShieldWall1 = true;
+        ShieldWall2 = true;
+
+        if (m_pInstance)
+        {
+            m_pInstance->SetData(TYPE_FOUR_HORSEMEN, NOT_STARTED);
+
+            if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_KORTHAZZ))))
+                if (!pTemp->isAlive())
+                    pTemp->Respawn();
+            if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_BLAUMEUX))))
+                if (!pTemp->isAlive())
+                    pTemp->Respawn();
+            if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_ZELIEK))))
+                if (!pTemp->isAlive())
+                    pTemp->Respawn();
+        }
     }
 
     void Aggro(Unit *who)
@@ -157,6 +241,9 @@
             case 1: DoScriptText(SAY_RIVE_AGGRO2, m_creature); break;
             case 2: DoScriptText(SAY_RIVE_AGGRO3, m_creature); break;
         }
+
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_FOUR_HORSEMEN, IN_PROGRESS);
     }
 
     void KilledUnit(Unit* Victim)
@@ -171,6 +258,23 @@
     void JustDied(Unit* Killer)
     {
         DoScriptText(SAY_RIVE_DEATH, m_creature);
+
+        if (m_pInstance)
+        {
+            bool HorsemenDead = true;
+            if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_KORTHAZZ))))
+                if (pTemp->isAlive())
+                    HorsemenDead = false;
+            if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_BLAUMEUX))))
+                if (pTemp->isAlive())
+                    HorsemenDead = false;
+            if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_ZELIEK))))
+                if (pTemp->isAlive())
+                    HorsemenDead = false;
+
+            if (HorsemenDead)
+                m_pInstance->SetData(TYPE_FOUR_HORSEMEN, DONE);
+        }
     }
 
     void UpdateAI(const uint32 diff)
@@ -178,6 +282,37 @@
         if (!m_creature->SelectHostilTarget() || !m_creature->getVictim())
             return;
 
+        // Mark of Blaumeux
+        if (Mark_Timer < diff)
+        {
+            DoCast(m_creature->getVictim(),SPELL_MARK_OF_RIVENDARE);
+            Mark_Timer = 15000;
+        }else Mark_Timer -= diff;
+
+        // Shield Wall - All 4 horsemen will shield wall at 50% hp and 20% hp for 20 seconds
+        if (ShieldWall1 && (m_creature->GetHealth()*100 / m_creature->GetMaxHealth()) < 50)
+        {
+            if (ShieldWall1)
+            {
+                DoCast(m_creature,SPELL_SHIELDWALL);
+                ShieldWall1 = false;
+            }
+        }
+        if (ShieldWall2 && (m_creature->GetHealth()*100 / m_creature->GetMaxHealth()) < 20)
+        {
+            if (ShieldWall2)
+            {
+                DoCast(m_creature,SPELL_SHIELDWALL);
+                ShieldWall2 = false;
+            }
+        }
+
+        if (UnholyShadow_Timer < diff)
+        {
+            DoCast(m_creature->getVictim(), m_bIsHeroicMode ? H_SPELL_UNHOLY_SHADOW : SPELL_UNHOLY_SHADOW);
+            UnholyShadow_Timer = 15000;
+        }else UnholyShadow_Timer -= diff;
+
         DoMeleeAttackIfReady();
     }
 };
@@ -203,8 +338,16 @@
 
 struct MANGOS_DLL_DECL boss_thane_korthazzAI : public ScriptedAI
 {
-    boss_thane_korthazzAI(Creature* pCreature) : ScriptedAI(pCreature) {Reset();}
+    boss_thane_korthazzAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsHeroicMode = pCreature->GetMap()->IsHeroic();
+        Reset();
+    }
 
+    ScriptedInstance* m_pInstance;
+    bool m_bIsHeroicMode;
+
     uint32 Mark_Timer;
     uint32 Meteor_Timer;
     bool ShieldWall1;
@@ -216,16 +359,51 @@
         Meteor_Timer = 30000;                               // wrong
         ShieldWall1 = true;
         ShieldWall2 = true;
+
+        if (m_pInstance)
+        {
+            m_pInstance->SetData(TYPE_FOUR_HORSEMEN, NOT_STARTED);
+
+            if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_RIVENDARE))))
+                if (!pTemp->isAlive())
+                    pTemp->Respawn();
+            if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_BLAUMEUX))))
+                if (!pTemp->isAlive())
+                    pTemp->Respawn();
+            if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_ZELIEK))))
+                if (!pTemp->isAlive())
+                    pTemp->Respawn();
+        }
     }
 
     void Aggro(Unit *who)
     {
         DoScriptText(SAY_KORT_AGGRO, m_creature);
+
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_FOUR_HORSEMEN, IN_PROGRESS);
     }
 
     void KilledUnit(Unit* Victim)
     {
         DoScriptText(SAY_KORT_SLAY, m_creature);
+
+        if (m_pInstance)
+        {
+            bool HorsemenDead = true;
+            if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_RIVENDARE))))
+                if (pTemp->isAlive())
+                    HorsemenDead = false;
+            if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_BLAUMEUX))))
+                if (pTemp->isAlive())
+                    HorsemenDead = false;
+            if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_ZELIEK))))
+                if (pTemp->isAlive())
+                    HorsemenDead = false;
+
+            if (HorsemenDead)
+                m_pInstance->SetData(TYPE_FOUR_HORSEMEN, DONE);
+        }
     }
 
     void JustDied(Unit* Killer)
@@ -267,7 +445,7 @@
         if (Meteor_Timer < diff)
         {
             DoCast(m_creature->getVictim(),SPELL_METEOR);
-            Meteor_Timer = 20000;                           // wrong
+            Meteor_Timer = 15000 + rand()%2000;
         }else Meteor_Timer -= diff;
 
         DoMeleeAttackIfReady();
@@ -298,10 +476,19 @@
 
 struct MANGOS_DLL_DECL boss_sir_zeliekAI : public ScriptedAI
 {
-    boss_sir_zeliekAI(Creature* pCreature) : ScriptedAI(pCreature) {Reset();}
+    boss_sir_zeliekAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsHeroicMode = pCreature->GetMap()->IsHeroic();
+        Reset();
+    }
 
+    ScriptedInstance* m_pInstance;
+    bool m_bIsHeroicMode;
+
     uint32 Mark_Timer;
     uint32 HolyWrath_Timer;
+    uint32 HolyBolt_Timer;
     bool ShieldWall1;
     bool ShieldWall2;
 
@@ -309,13 +496,32 @@
     {
         Mark_Timer = 20000;                                 // First Horsemen Mark is applied at 20 sec.
         HolyWrath_Timer = 12000;                            // right
+        HolyBolt_Timer = 5000;
         ShieldWall1 = true;
         ShieldWall2 = true;
+
+        if (m_pInstance)
+        {
+            m_pInstance->SetData(TYPE_FOUR_HORSEMEN, NOT_STARTED);
+
+            if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_KORTHAZZ))))
+                if (!pTemp->isAlive())
+                    pTemp->Respawn();
+            if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_RIVENDARE))))
+                if (!pTemp->isAlive())
+                    pTemp->Respawn();
+            if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_BLAUMEUX))))
+                if (!pTemp->isAlive())
+                    pTemp->Respawn();
+        }
     }
 
     void Aggro(Unit *who)
     {
         DoScriptText(SAY_ZELI_AGGRO, m_creature);
+
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_FOUR_HORSEMEN, IN_PROGRESS);
     }
 
     void KilledUnit(Unit* Victim)
@@ -326,6 +532,23 @@
     void JustDied(Unit* Killer)
     {
         DoScriptText(SAY_ZELI_DEATH, m_creature);
+
+        if (m_pInstance)
+        {
+            bool HorsemenDead = true;
+            if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_KORTHAZZ))))
+                if (pTemp->isAlive())
+                    HorsemenDead = false;
+            if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_RIVENDARE))))
+                if (pTemp->isAlive())
+                    HorsemenDead = false;
+            if (Creature* pTemp = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_BLAUMEUX))))
+                if (pTemp->isAlive())
+                    HorsemenDead = false;
+
+            if (HorsemenDead)
+                m_pInstance->SetData(TYPE_FOUR_HORSEMEN, DONE);
+        }
     }
 
     void UpdateAI(const uint32 diff)
@@ -359,10 +582,16 @@
             }
         }
 
+        if (HolyBolt_Timer < diff)
+        {
+            DoCast(m_creature->getVictim(), m_bIsHeroicMode ? H_SPELL_HOLY_BOLT : SPELL_HOLY_BOLT);
+            HolyBolt_Timer = 5000;
+        }else HolyBolt_Timer -= diff;
+
         // Holy Wrath
         if (HolyWrath_Timer < diff)
         {
-            DoCast(m_creature->getVictim(),SPELL_HOLY_WRATH);
+            DoCast(m_creature->getVictim(), m_bIsHeroicMode ? H_SPELL_HOLY_WRATH : SPELL_HOLY_WRATH);
             HolyWrath_Timer = 12000;
         }else HolyWrath_Timer -= diff;
 
Index: boss_gluth.cpp
===================================================================
--- boss_gluth.cpp	(revision 1388)
+++ boss_gluth.cpp	(working copy)
@@ -22,6 +22,7 @@
 EndScriptData */
 
 #include "precompiled.h"
+#include "def_naxxramas.h"
 
 enum
 {
@@ -34,6 +35,7 @@
     SPELL_BERSERK                   = 26662,
 
     NPC_ZOMBIE_CHOW                 = 16360,
+    SPELL_INFECTED_WOUND            = 29306,
 };
 
 #define ADD_1X 3269.590
@@ -72,6 +74,45 @@
 #define ADD_9Y -3180.766
 #define ADD_9Z 297.423
 
+struct MANGOS_DLL_DECL mob_zombie_chowsAI : public ScriptedAI
+{
+    mob_zombie_chowsAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        Reset();
+    }
+
+    bool bIsForceMove;
+
+    void Reset()
+    {
+        bIsForceMove = false;
+    }
+    void JustDied(Unit* Killer) {}
+
+    void DoMeleeAttackIfReady()
+    {
+        //If we are within range melee the target
+        if (m_creature->IsWithinDistInMap(m_creature->getVictim(), ATTACK_DISTANCE))
+        {
+            //Make sure our attack is ready and we aren't currently casting
+            if (m_creature->isAttackReady() && !m_creature->IsNonMeleeSpellCasted(false))
+            {
+                DoCast(m_creature->getVictim(), SPELL_INFECTED_WOUND, true);
+                m_creature->AttackerStateUpdate(m_creature->getVictim());
+                m_creature->resetAttackTimer();
+            }
+        }
+    }
+
+    void UpdateAI(const uint32 diff)
+    {
+        if (!m_creature->SelectHostilTarget() || !m_creature->getVictim() || bIsForceMove)
+            return;
+
+        DoMeleeAttackIfReady();
+    }
+};
+
 struct MANGOS_DLL_DECL boss_gluthAI : public ScriptedAI
 {
     boss_gluthAI(Creature* pCreature) : ScriptedAI(pCreature)
@@ -84,12 +125,14 @@
     ScriptedInstance* m_pInstance;
     bool m_bIsHeroicMode;
 
+    std::list<uint64> m_lZombieGUIDList;
+
     uint32 MortalWound_Timer;
     uint32 Decimate_Timer;
     uint32 Enrage_Timer;
     uint32 Summon_Timer;
-
     uint32 m_uiBerserkTimer;
+    uint32 RangeCheck_Timer;
 
     void Reset()
     {
@@ -97,10 +140,32 @@
         Decimate_Timer = 100000;
         Enrage_Timer = 60000;
         Summon_Timer = 10000;
+        RangeCheck_Timer = 1000;
 
         m_uiBerserkTimer = MINUTE*8*IN_MILISECONDS;
+        m_lZombieGUIDList.clear();
+
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_GLUTH, NOT_STARTED);
     }
 
+    void JustDied(Unit* Killer)
+    {
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_GLUTH, DONE);
+    }
+
+    void Aggro(Unit *who)
+    {
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_GLUTH, IN_PROGRESS);
+    }
+
+    void JustSummoned(Creature* summoned)
+    {
+        summoned->SetSpeed(MOVE_RUN, 0.8f);
+    }
+
     void UpdateAI(const uint32 diff)
     {
         if (!m_creature->SelectHostilTarget() || !m_creature->getVictim())
@@ -116,8 +181,37 @@
         //Decimate_Timer
         if (Decimate_Timer < diff)
         {
-            DoCast(m_creature->getVictim(),SPELL_DECIMATE);
-            Decimate_Timer = 100000;
+            DoCast(m_creature->getVictim(),SPELL_DECIMATE); // need core support
+
+            // workaround below
+            std::list<HostilReference *> t_list = m_creature->getThreatManager().getThreatList();
+            if (t_list.size())
+            {
+                //begin + 1 , so we don't target the one with the highest threat
+                std::list<HostilReference *>::iterator itr = t_list.begin();
+                std::advance(itr, 1);
+                for(; itr!= t_list.end(); ++itr)
+                {
+                    Unit *target = Unit::GetUnit(*m_creature, (*itr)->getUnitGuid());
+                    if (target && target->isAlive() && target->GetTypeId() == TYPEID_PLAYER &&
+                    	(target->GetHealth() > target->GetMaxHealth() * 0.05))
+                        target->SetHealth(target->GetMaxHealth() * 0.05);
+                }
+            }
+            // Move Zombies
+            if (!m_lZombieGUIDList.empty())
+            {
+                for(std::list<uint64>::iterator itr = m_lZombieGUIDList.begin(); itr != m_lZombieGUIDList.end(); ++itr)
+                    if (Creature* pTemp = (Creature*)Unit::GetUnit(*m_creature, *itr))
+                        if (pTemp->isAlive())
+                        {
+                            ((mob_zombie_chowsAI*)pTemp->AI())->bIsForceMove = true;
+                            if (m_creature->GetHealth() > m_creature->GetMaxHealth() * 0.05) // remove when SPELL_DECIMATE is working
+                                pTemp->SetHealth(pTemp->GetMaxHealth() * 0.02);
+                            pTemp->AddThreat(m_creature, 1000000000.0f); // force move toward to Gluth
+                        }
+            }
+            Decimate_Timer = (m_bIsHeroicMode ? 120000 : 100000);
         }else Decimate_Timer -= diff;
 
         //Enrage_Timer
@@ -127,24 +221,36 @@
             Enrage_Timer = 60000;
         }else Enrage_Timer -= diff;
 
-        //Summon_Timer
-        if (Summon_Timer < diff)
+        if (RangeCheck_Timer < diff)
         {
-            if (Creature* pZombie = m_creature->SummonCreature(NPC_ZOMBIE_CHOW,ADD_1X,ADD_1Y,ADD_1Z,0,TEMPSUMMON_TIMED_OR_DEAD_DESPAWN,80000))
+            if (!m_lZombieGUIDList.empty())
             {
-                if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
-                    pZombie->AddThreat(pTarget,0.0f);
+                for(std::list<uint64>::iterator itr = m_lZombieGUIDList.begin(); itr != m_lZombieGUIDList.end(); ++itr)
+                    if (Creature* pTemp = (Creature*)Unit::GetUnit(*m_creature, *itr))
+                        if (pTemp->isAlive() && m_creature->IsWithinDistInMap(pTemp, ATTACK_DISTANCE))
+                        {
+                            DoScriptText(EMOTE_ZOMBIE, m_creature);
+                            m_creature->SetHealth(m_creature->GetHealth() + m_creature->GetMaxHealth() * 0.05);
+                            pTemp->ForcedDespawn();
+                        }
             }
+            RangeCheck_Timer = 1000;
+        }else RangeCheck_Timer -= diff;
 
-            if (m_bIsHeroicMode)
+        //Summon_Timer
+        if (Summon_Timer < diff)
+        {
+            for(uint8 i = 0; i < (m_bIsHeroicMode ? 2 : 1); i++)
             {
                 if (Creature* pZombie = m_creature->SummonCreature(NPC_ZOMBIE_CHOW,ADD_1X,ADD_1Y,ADD_1Z,0,TEMPSUMMON_TIMED_OR_DEAD_DESPAWN,80000))
                 {
                     if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
-                        pZombie->AddThreat(pTarget,0.0f);
+                    {
+                        pZombie->AI()->AttackStart(pTarget);
+                        m_lZombieGUIDList.push_back(pZombie->GetGUID());
+                    }
                 }
             }
-
             Summon_Timer = 10000;
         } else Summon_Timer -= diff;
 
@@ -164,6 +270,11 @@
     return new boss_gluthAI(pCreature);
 }
 
+CreatureAI* GetAI_mob_zombie_chows(Creature* pCreature)
+{
+    return new mob_zombie_chowsAI(pCreature);
+}
+
 void AddSC_boss_gluth()
 {
     Script *newscript;
@@ -171,4 +282,9 @@
     newscript->Name = "boss_gluth";
     newscript->GetAI = &GetAI_boss_gluth;
     newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "mob_zombie_chows";
+    newscript->GetAI = &GetAI_mob_zombie_chows;
+    newscript->RegisterSelf();
 }
Index: boss_gothik.cpp
===================================================================
--- boss_gothik.cpp	(revision 1388)
+++ boss_gothik.cpp	(working copy)
@@ -16,12 +16,14 @@
 
 /* ScriptData
 SDName: Boss_Gothik
+SDAuthor: ckegg
 SD%Complete: 0
-SDComment: Placeholder
+SDComment: Center gate.........?
 SDCategory: Naxxramas
 EndScriptData */
 
 #include "precompiled.h"
+#include "def_naxxramas.h"
 
 #define SAY_SPEECH                  -1533040
 #define SAY_KILL                    -1533041
@@ -62,3 +64,253 @@
 
 //Spectral Horse
 #define SPELL_STOMP                 27993
+
+#define MOB_LIVE_TRAINEE    16124
+#define MOB_LIVE_KNIGHT     16125
+#define MOB_LIVE_RIDER      16126
+#define MOB_DEAD_TRAINEE    16127
+#define MOB_DEAD_KNIGHT     16148
+#define MOB_DEAD_RIDER      16150
+#define MOB_DEAD_HORSE      16149
+
+#define POS_LIVE 3
+#define POS_DEAD 5
+
+const struct Waves { uint32 entry, number, time; }
+waves[] =
+{
+    {MOB_LIVE_TRAINEE, 2, 20000},
+    {MOB_LIVE_TRAINEE, 2, 20000},
+    {MOB_LIVE_TRAINEE, 2, 10000},
+    {MOB_LIVE_KNIGHT,  1, 10000}, // 60
+    {MOB_LIVE_TRAINEE, 2, 15000}, 
+    {MOB_LIVE_KNIGHT,  1, 10000},
+    {MOB_LIVE_TRAINEE, 2, 15000},
+    {MOB_LIVE_TRAINEE, 2, 0},
+    {MOB_LIVE_KNIGHT,  1, 10000},
+    {MOB_LIVE_RIDER,   1, 10000}, // 120
+    {MOB_LIVE_TRAINEE, 2, 5000},
+    {MOB_LIVE_KNIGHT,  1, 15000},
+    {MOB_LIVE_TRAINEE, 2, 0},
+    {MOB_LIVE_RIDER,   1, 10000},
+    {MOB_LIVE_KNIGHT,  1, 10000},
+    {MOB_LIVE_TRAINEE, 2, 10000},
+    {MOB_LIVE_RIDER,   1, 5000},
+    {MOB_LIVE_KNIGHT,  1, 5000},  // 180
+    {MOB_LIVE_TRAINEE, 2, 20000},
+    {MOB_LIVE_TRAINEE, 2, 0},
+    {MOB_LIVE_KNIGHT,  1, 0},
+    {MOB_LIVE_RIDER,   1, 15000},
+    {MOB_LIVE_TRAINEE, 2, 29000}, // 244
+    {0, 0, 0},
+};
+
+const float PosSummonLive[POS_LIVE][3] =
+{
+    {2669.7, -3430.9, 268.56},
+    {2692.0, -3430.9, 268.56},
+    {2714.1, -3430.9, 268.56},
+};
+
+const float PosSummonDead[POS_DEAD][3] =
+{
+    {2725.1, -3310.0, 268.85},
+    {2699.3, -3322.8, 268.60},
+    {2733.1, -3348.5, 268.84},
+    {2682.8, -3304.2, 268.85},
+    {2664.8, -3340.7, 268.23},
+};
+
+const float PosPlatform[4] = {2640.5, -3360.6, 285.26, 0};
+const float PosGroundLive[4] = {2692.174, -3400.963, 267.680, 1.7};
+const float PosGroundDeath[4] = {2690.378, -3328.279, 267.681, 1.7};
+
+struct MANGOS_DLL_DECL boss_gothikAI : public Scripted_NoMovementAI
+{
+    boss_gothikAI(Creature* pCreature) : Scripted_NoMovementAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsHeroicMode = pCreature->GetMap()->IsHeroic();
+        Reset();
+    }
+
+    ScriptedInstance* m_pInstance;
+    bool m_bIsHeroicMode;
+    bool SummonPhase;
+    bool BlinkPhase;
+
+    std::list<uint64> SummonsList;
+
+    uint32 waveCount;
+    uint32 Summon_Timer;
+    uint32 SummonDeathCheck_Timer;
+    uint32 HarvestSoul_Timer;
+    uint32 ShadowBolt_Timer;
+    uint32 Blink_Timer;
+
+    void Reset()
+    {
+    	SummonPhase = false;
+    	BlinkPhase = false;
+
+    	SummonsList.clear();
+
+        waveCount = 0;
+        Summon_Timer = 10000;
+        SummonDeathCheck_Timer = 1000;
+        HarvestSoul_Timer = 15000;
+        ShadowBolt_Timer = 1000;
+        Blink_Timer = 30000;
+
+        m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_GOTHIK, NOT_STARTED);
+    }
+
+    void EnterCombat(Unit *who)
+    {
+        DoScriptText(SAY_SPEECH, m_creature);
+
+        m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+        m_creature->GetMap()->CreatureRelocation(m_creature, PosPlatform[0], PosPlatform[1], PosPlatform[2], PosPlatform[3]);
+        m_creature->SetInCombatWithZone();
+
+        if (m_pInstance)
+        {
+            m_pInstance->SetData(TYPE_GOTHIK, IN_PROGRESS);
+
+            if (GameObject* pGate = m_pInstance->instance->GetGameObject(m_pInstance->GetData64(DATA_GOTHIK_GATE)))
+                pGate->SetGoState(GO_STATE_READY);
+        }
+    }
+
+    void KilledUnit(Unit* victim)
+    {
+        if(!(rand()%5))
+            DoScriptText(SAY_KILL, m_creature);
+    }
+
+    void JustDied(Unit* Killer)
+    {
+        DoScriptText(SAY_DEATH, m_creature);
+
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_GOTHIK, DONE);
+    }
+
+    void JustSummoned(Creature* pSummon)
+    {
+        pSummon->AI()->AttackStart(SelectUnit(SELECT_TARGET_RANDOM,0));
+    }
+
+    void UpdateAI(const uint32 diff)
+    {
+        if (!m_creature->SelectHostilTarget() || !m_creature->getVictim())
+            return;
+
+        if (SummonPhase)
+        {
+            if (HarvestSoul_Timer < diff)
+            {
+                DoCast(m_creature->getVictim(), SPELL_HARVESTSOUL);
+                HarvestSoul_Timer = 15000 + rand()%1000;
+            }else HarvestSoul_Timer -= diff;
+
+            if (ShadowBolt_Timer < diff)
+            {
+                DoCast(m_creature->getVictim(), m_bIsHeroicMode ? H_SPELL_SHADOWBOLT : SPELL_SHADOWBOLT);
+                ShadowBolt_Timer = 1000 + rand()%500;
+            }else ShadowBolt_Timer -= diff;
+
+            if (Blink_Timer < diff)
+            {
+                if (BlinkPhase)
+                {
+                    m_creature->GetMap()->CreatureRelocation(m_creature, PosGroundLive[0], PosGroundLive[1], PosGroundLive[2], 0.0f);
+                    BlinkPhase = false;
+                }
+                else
+                {
+                    m_creature->GetMap()->CreatureRelocation(m_creature, PosGroundDeath[0], PosGroundDeath[1], PosGroundDeath[2], 0.0f);
+                    BlinkPhase = true;
+                }
+                DoResetThreat();
+                Blink_Timer = 15000;
+            }else Blink_Timer -= diff;
+        }
+        else
+        {
+            if (Summon_Timer < diff)
+            {
+                if(waves[waveCount].entry)
+                {
+                    for(uint32 i = 0; i < waves[waveCount].number; ++i)
+                    {
+                        uint8 SummonLoc = rand()%POS_LIVE;
+                        if (Creature* pTemp = m_creature->SummonCreature(waves[waveCount].entry, PosSummonLive[SummonLoc][0], PosSummonLive[SummonLoc][1], PosSummonLive[SummonLoc][2], 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 30000))
+                            SummonsList.push_back(pTemp->GetGUID());
+                    }
+                    Summon_Timer = waves[waveCount].time;
+                    ++waveCount;
+                }
+                else
+                {
+                    DoScriptText(SAY_TELEPORT, m_creature);
+                    uint8 SummonLoc = rand()%POS_LIVE;
+                    m_creature->GetMap()->CreatureRelocation(m_creature, PosSummonLive[SummonLoc][0], PosSummonLive[SummonLoc][1], PosSummonLive[SummonLoc][2], 0.0f);
+                    m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+
+                    SummonPhase = true;
+                }
+            }else Summon_Timer -= diff;
+        }
+
+        if (SummonDeathCheck_Timer < diff)
+        {
+            if (!SummonsList.empty())
+            {
+                for(std::list<uint64>::iterator itr = SummonsList.begin(); itr != SummonsList.end(); ++itr)
+                {
+                    if (Creature* pTemp = ((Creature*)Unit::GetUnit(*m_creature, *itr)))
+                    {
+                        if (!pTemp->isAlive())
+                        {
+                            uint8 SummonLoc = rand()%POS_DEAD;
+                            if (pTemp->GetEntry() == MOB_LIVE_TRAINEE)
+                                m_creature->SummonCreature(MOB_DEAD_TRAINEE, PosSummonDead[SummonLoc][0], PosSummonDead[SummonLoc][1], PosSummonDead[SummonLoc][2], 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 30000);
+                            else if (pTemp->GetEntry() == MOB_LIVE_KNIGHT)
+                                m_creature->SummonCreature(MOB_DEAD_KNIGHT, PosSummonDead[SummonLoc][0], PosSummonDead[SummonLoc][1], PosSummonDead[SummonLoc][2], 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 30000);
+                            else if (pTemp->GetEntry() == MOB_LIVE_RIDER)
+                            {
+                                m_creature->SummonCreature(MOB_DEAD_RIDER, PosSummonDead[SummonLoc][0], PosSummonDead[SummonLoc][1], PosSummonDead[SummonLoc][2], 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 30000);
+                                m_creature->SummonCreature(MOB_DEAD_HORSE, PosSummonDead[SummonLoc][0], PosSummonDead[SummonLoc][1], PosSummonDead[SummonLoc][2], 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 30000);
+                            }
+
+                            if (m_pInstance)
+                                if (GameObject* pGate = m_pInstance->instance->GetGameObject(m_pInstance->GetData64(DATA_GOTHIK_GATE)))
+                                    pGate->SetGoState(GO_STATE_ACTIVE);
+                            SummonsList.remove(pTemp->GetGUID());
+                            break;
+                        }
+                    }
+                }
+            }
+            SummonDeathCheck_Timer = 1000;
+        }else SummonDeathCheck_Timer -= diff;
+    }
+};
+
+CreatureAI* GetAI_boss_gothik(Creature* pCreature)
+{
+    return new boss_gothikAI(pCreature);
+}
+
+void AddSC_boss_gothik()
+{
+    Script *newscript;
+    newscript = new Script;
+    newscript->Name = "boss_gothik";
+    newscript->GetAI = &GetAI_boss_gothik;
+    newscript->RegisterSelf();
+}
Index: boss_grobbulus.cpp
===================================================================
--- boss_grobbulus.cpp	(revision 1388)
+++ boss_grobbulus.cpp	(working copy)
@@ -16,15 +16,158 @@
 
 /* ScriptData
 SDName: Boss_Grobbulus
+SDAuthor: ckegg
 SD%Complete: 0
 SDComment: Place holder
 SDCategory: Naxxramas
 EndScriptData */
 
-/*Poison Cloud 26590
-Slime Spray 28157
-Fallout slime 28218
-Mutating Injection 28169
-Enrages 26527*/
+#include "precompiled.h"
+#include "def_naxxramas.h"
 
-#include "precompiled.h"
+#define SPELL_BOMBARD_SLIME         28280
+
+#define SPELL_POISON_CLOUD          28240
+#define SPELL_MUTATING_INJECTION    28169
+#define SPELL_SLIME_SPRAY           28157
+#define H_SPELL_SLIME_SPRAY         54364
+#define SPELL_BERSERK               26662
+
+#define MOB_FALLOUT_SLIME   16290
+
+struct MANGOS_DLL_DECL boss_grobbulusAI : public ScriptedAI
+{
+    boss_grobbulusAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsHeroicMode = pCreature->GetMap()->IsHeroic();
+        Reset();
+    }
+
+    ScriptedInstance* m_pInstance;
+    bool m_bIsHeroicMode;
+
+    uint32 PoisonCloud_Timer;
+    uint32 MutatingInjection_Timer;
+    uint32 SlimeSpary_Timer;
+    uint32 Enrage_Timer;
+
+    void Reset()
+    {
+        PoisonCloud_Timer = 15000;
+        MutatingInjection_Timer = 20000;
+        SlimeSpary_Timer = 15000+rand()%15000;
+        Enrage_Timer = 300000;
+
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_GROBBULUS, NOT_STARTED);
+    }
+
+    void JustDied(Unit* Killer)
+    {
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_GROBBULUS, DONE);
+    }
+
+    void Aggro(Unit *who)
+    {
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_GROBBULUS, IN_PROGRESS);
+    }
+
+    void SpellHitTarget(Unit *target, const SpellEntry *spell)
+    {
+        if(spell->Id == SPELL_SLIME_SPRAY || spell->Id == H_SPELL_SLIME_SPRAY)
+        {
+            if (Creature* pTemp = m_creature->SummonCreature(MOB_FALLOUT_SLIME, target->GetPositionX(), target->GetPositionY(), target->GetPositionZ(), 0, TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT, 1000))
+                if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
+                {
+                    pTemp->AddThreat(pTarget,0.0f);
+                    pTemp->AI()->AttackStart(pTarget);
+                }
+        }
+    }
+
+    void UpdateAI(const uint32 diff)
+    {
+        if (!m_creature->SelectHostilTarget() || !m_creature->getVictim())
+            return;
+
+        if (PoisonCloud_Timer < diff)
+        {
+            DoCast(m_creature, SPELL_POISON_CLOUD);
+            PoisonCloud_Timer = 15000;
+        }else PoisonCloud_Timer -= diff;
+
+        if (MutatingInjection_Timer < diff)
+        {
+            if (Unit* target = SelectUnit(SELECT_TARGET_RANDOM,0))
+                DoCast(target, SPELL_MUTATING_INJECTION);
+
+            MutatingInjection_Timer = 20000;
+        }else MutatingInjection_Timer -= diff;
+
+        if (SlimeSpary_Timer < diff)
+        {
+            DoCast(m_creature, m_bIsHeroicMode ? H_SPELL_SLIME_SPRAY : SPELL_SLIME_SPRAY);
+            SlimeSpary_Timer = 15000+rand()%15000;
+        }else SlimeSpary_Timer -= diff;
+
+        if (Enrage_Timer < diff)
+        {
+            DoCast(m_creature, SPELL_BERSERK);
+            Enrage_Timer = 300000;
+        }else Enrage_Timer -= diff;
+
+        DoMeleeAttackIfReady();
+    }
+};
+
+struct MANGOS_DLL_DECL npc_grobbulus_poison_cloudAI : public Scripted_NoMovementAI
+{
+    npc_grobbulus_poison_cloudAI(Creature* pCreature) : Scripted_NoMovementAI(pCreature)
+    {
+        Reset();
+    }
+
+    uint32 Cloud_Timer;
+
+    void Reset()
+    {
+        Cloud_Timer = 1000;
+        m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+    }
+
+    void UpdateAI(const uint32 diff)
+    {
+        if (Cloud_Timer < diff)
+        {
+            DoCast(m_creature, 59116);
+            Cloud_Timer = 10000;
+        }else Cloud_Timer -= diff;
+    }
+};
+
+CreatureAI* GetAI_boss_grobbulus(Creature* pCreature)
+{
+    return new boss_grobbulusAI(pCreature);
+}
+
+CreatureAI* GetAI_npc_grobbulus_poison_cloud(Creature* pCreature)
+{
+    return new npc_grobbulus_poison_cloudAI(pCreature);
+}
+
+void AddSC_boss_grobbulus()
+{
+    Script *newscript;
+    newscript = new Script;
+    newscript->Name = "boss_grobbulus";
+    newscript->GetAI = &GetAI_boss_grobbulus;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "npc_grobbulus_poison_cloud";
+    newscript->GetAI = &GetAI_npc_grobbulus_poison_cloud;
+    newscript->RegisterSelf();
+}
Index: boss_heigan.cpp
===================================================================
--- boss_heigan.cpp	(revision 1388)
+++ boss_heigan.cpp	(working copy)
@@ -22,6 +22,7 @@
 EndScriptData */
 
 #include "precompiled.h"
+#include "def_naxxramas.h"
 
 #define SAY_AGGRO1          -1533109
 #define SAY_AGGRO2          -1533110
@@ -38,8 +39,95 @@
 #define SPELL_ERUPTION      29371
 
 //Spells by boss
-#define SPELL_WILT          23772
+#define SPELL_DISRUPTION    29310
 #define SPELL_FEAVER        29998
+#define H_SPELL_FEAVER      55011
 
 //Spell by eye stalks
 #define SPELL_MIND_FLAY     26143
+
+
+struct MANGOS_DLL_DECL boss_heiganAI : public ScriptedAI
+{
+    boss_heiganAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsHeroicMode = pCreature->GetMap()->IsHeroic();
+        Reset();
+    }
+
+    ScriptedInstance* m_pInstance;
+    bool m_bIsHeroicMode;
+
+    uint32 Disruption_Timer;
+    uint32 Feaver_Timer;
+
+    void Reset()
+    {
+    	Disruption_Timer = 5000+rand()%10000;
+    	Feaver_Timer = 40000;
+
+        if(m_pInstance)
+            m_pInstance->SetData(TYPE_HEIGAN, NOT_STARTED);
+    }
+
+    void Aggro(Unit *who)
+    {
+        switch (rand()%3)
+        {
+            case 0: DoScriptText(SAY_AGGRO1, m_creature); break;
+            case 1: DoScriptText(SAY_AGGRO2, m_creature); break;
+            case 2: DoScriptText(SAY_AGGRO3, m_creature); break;
+        }
+
+        if(m_pInstance)
+            m_pInstance->SetData(TYPE_HEIGAN, IN_PROGRESS);
+    }
+
+    void KilledUnit(Unit* victim)
+    {
+        DoScriptText(SAY_SLAY, m_creature);
+    }
+
+    void JustDied(Unit* Killer)
+    {
+        DoScriptText(SAY_DEATH, m_creature);
+
+        if(m_pInstance)
+            m_pInstance->SetData(TYPE_HEIGAN, DONE);
+    }
+
+    void UpdateAI(const uint32 diff)
+    {
+        if (!m_creature->SelectHostilTarget() || !m_creature->getVictim())
+            return;
+
+        if (Disruption_Timer < diff)
+        {
+            DoCast(m_creature->getVictim(), SPELL_DISRUPTION);
+            Disruption_Timer = 5000+rand()%10000;
+        }else Disruption_Timer -= diff;
+
+        if (Feaver_Timer < diff)
+        {
+            DoCast(m_creature->getVictim(), m_bIsHeroicMode ? H_SPELL_FEAVER : SPELL_FEAVER);
+            Feaver_Timer = 30000+rand()%10000;
+        }else Feaver_Timer -= diff;
+
+        DoMeleeAttackIfReady();
+    }
+};
+
+CreatureAI* GetAI_boss_heigan(Creature* pCreature)
+{
+    return new boss_heiganAI(pCreature);
+}
+
+void AddSC_boss_heigan()
+{
+    Script *newscript;
+    newscript = new Script;
+    newscript->Name = "boss_heigan";
+    newscript->GetAI = &GetAI_boss_heigan;
+    newscript->RegisterSelf();
+}
Index: boss_kelthuzad.cpp
===================================================================
--- boss_kelthuzad.cpp	(revision 1388)
+++ boss_kelthuzad.cpp	(working copy)
@@ -22,6 +22,7 @@
 EndScriptData */
 
 #include "precompiled.h"
+#include "def_naxxramas.h"
 
 //when shappiron dies. dialog between kel and lich king (in this order)
 #define SAY_SAPP_DIALOG1            -1533084
@@ -76,13 +77,13 @@
 */
 
 //Positional defines
-#define ADDX_LEFT_FAR               3783.272705
-#define ADDY_LEFT_FAR               -5062.697266
+#define ADDX_LEFT_FAR               3769.272705
+#define ADDY_LEFT_FAR               -5071.697266
 #define ADDZ_LEFT_FAR               143.711203
 #define ADDO_LEFT_FAR               3.617599
 
-#define ADDX_LEFT_MIDDLE            3730.291260
-#define ADDY_LEFT_MIDDLE            -5027.239258
+#define ADDX_LEFT_MIDDLE            3729.291260
+#define ADDY_LEFT_MIDDLE            -5044.239258
 #define ADDZ_LEFT_MIDDLE            143.956909
 #define ADDO_LEFT_MIDDLE            4.461900
 
@@ -91,13 +92,13 @@
 #define ADDZ_LEFT_NEAR              143.183884
 #define ADDO_LEFT_NEAR              5.237086
 
-#define ADDX_RIGHT_FAR              3759.355225
-#define ADDY_RIGHT_FAR              -5174.128418
+#define ADDX_RIGHT_FAR              3749.355225
+#define ADDY_RIGHT_FAR              -5158.128418
 #define ADDZ_RIGHT_FAR              143.802383
 #define ADDO_RIGHT_FAR              2.170104
 
-#define ADDX_RIGHT_MIDDLE           370.724365
-#define ADDY_RIGHT_MIDDLE           -5185.123047
+#define ADDX_RIGHT_MIDDLE           3703.724365
+#define ADDY_RIGHT_MIDDLE           -5169.123047
 #define ADDZ_RIGHT_MIDDLE           143.928024
 #define ADDO_RIGHT_MIDDLE           1.309310
 
@@ -136,6 +137,10 @@
 #define WALKZ_RIGHT_NEAR            142.0141130
 #define WALKO_RIGHT_NEAR            2.121412
 
+#define WALKX_MIDDLE                3716.384
+#define WALKY_MIDDLE                -5106.453
+#define WALKZ_MIDDLE                142
+
 //spells to be casted
 #define SPELL_FROST_BOLT            28478
 #define H_SPELL_FROST_BOLT          55802
@@ -147,10 +152,19 @@
 #define SPELL_SHADOW_FISURE         27810
 #define SPELL_FROST_BLAST           27808
 
+#define NPC_SOLDIERS_FROZEN_WASTES  16427
+#define NPC_UNSTOPPABLE_ABOMINATIONS 16428
+#define NPC_SOUL_WEAVERS            16429
+
+#define HOME_X                      3748
+#define HOME_Y                      -5113
+
 struct MANGOS_DLL_DECL boss_kelthuzadAI : public ScriptedAI
 {
     boss_kelthuzadAI(Creature* pCreature) : ScriptedAI(pCreature)
     {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsHeroic = pCreature->GetMap()->IsHeroic();
         GuardiansOfIcecrown[0] = 0;
         GuardiansOfIcecrown[1] = 0;
         GuardiansOfIcecrown[2] = 0;
@@ -159,7 +173,12 @@
         GuardiansOfIcecrown_Count = 0;
         Reset();
     }
+    ScriptedInstance *m_pInstance;
+    bool m_bIsHeroic;
 
+    std::list<uint64> m_lSummonsGUIDList;
+    std::list<uint64>::iterator m_uiSendSummon;
+
     uint64 GuardiansOfIcecrown[5];
     uint32 GuardiansOfIcecrown_Count;
     uint32 GuardiansOfIcecrown_Timer;
@@ -171,6 +190,9 @@
     uint32 FrostBlast_Timer;
     uint32 ChainsOfKelthuzad_Targets;
     uint32 Phase1_Timer;
+    uint32 Phase1Encounter_Timer;
+    bool SendSummon;
+    bool Phase1;
     bool Phase2;
     bool Phase3;
 
@@ -192,16 +214,26 @@
                 if (Creature* pGuardian = (Creature*)Unit::GetUnit(*m_creature, GuardiansOfIcecrown[i]))
                 {
                     if (pGuardian->isAlive())
-                        pGuardian->ForcedDespawn();
+                        //pGuardian->ForcedDespawn();
+                        pGuardian->DealDamage(pGuardian, pGuardian->GetHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
                 }
 
                 GuardiansOfIcecrown[i] = 0;
             }
         }
+        DespawnSummons();
 
         Phase1_Timer = 310000;                              //Phase 1 lasts 5 minutes and 10 seconds
+        Phase1Encounter_Timer = 3000;
+        SendSummon = false;
+        Phase1 = false;
         Phase2 = false;
         Phase3 = false;
+
+        m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_KELTHUZAD, NOT_STARTED);
     }
 
     void KilledUnit()
@@ -225,6 +257,7 @@
                 if (!pGuardian || !pGuardian->isAlive())
                     continue;
 
+                pGuardian->setFaction(35);
                 pGuardian->CombatStop();
 
                 float Walk_Pos_X = 0.0f;
@@ -265,11 +298,45 @@
                         break;
                 }
 
-                pGuardian->SendMonsterMoveWithSpeed(Walk_Pos_X, Walk_Pos_Y, Walk_Pos_Z);
+                //pGuardian->SendMonsterMoveWithSpeed(Walk_Pos_X, Walk_Pos_Y, Walk_Pos_Z);
+                pGuardian->GetMotionMaster()->MovePoint(0, Walk_Pos_X, Walk_Pos_Y, Walk_Pos_Z);
             }
         }
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_KELTHUZAD, DONE);
     }
 
+    void MoveInLineOfSight(Unit* who)
+    {
+        if (!who)
+            return;
+
+        if (Phase1 || Phase2 || Phase3)
+            return;
+
+        if (who->isTargetableForAttack() && who->GetTypeId() == TYPEID_PLAYER && m_creature->GetDistance2d(who) <= 50)
+        {
+            m_creature->AddThreat(who, 0.0f);
+            m_creature->SetInCombatWith(who);
+
+            for(uint8 i = 0; i <= 80; ++i)
+            {
+                if (i == 5 || i == 15 || i == 25 || i == 35 || i == 45 || i == 55 || i == 65 || i == 75)
+                    DoSpawnAdds(NPC_SOUL_WEAVERS);
+                else if (i == 10 || i == 20 || i == 30 || i == 40 || i == 50 || i == 60 || i == 70 || i == 80)
+                    DoSpawnAdds(NPC_UNSTOPPABLE_ABOMINATIONS);
+                else
+                    DoSpawnAdds(NPC_SOLDIERS_FROZEN_WASTES);
+            }
+            if (!m_lSummonsGUIDList.empty())
+            {
+                m_uiSendSummon = m_lSummonsGUIDList.begin();
+                SendSummon = true;
+            }
+            Phase1 = true;
+        }
+    }
+
     void Aggro(Unit* who)
     {
         switch(rand()%3)
@@ -278,24 +345,141 @@
             case 1: DoScriptText(SAY_AGGRO2, m_creature); break;
             case 2: DoScriptText(SAY_AGGRO3, m_creature); break;
         }
+
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_KELTHUZAD, IN_PROGRESS);
     }
 
+    void AttackStart(Unit* pWho)
+    {
+        if (!pWho)
+            return;
+
+        if (!Phase2)
+            return;
+
+        if (m_creature->Attack(pWho, true))
+        {
+            m_creature->AddThreat(pWho, 0.0f);
+            m_creature->SetInCombatWithZone();
+            //m_creature->SetInCombatWith(pWho);
+            //pWho->SetInCombatWith(m_creature);
+            DoStartMovement(pWho);
+        }
+    }
+
+    void DoSpawnAdds(uint32 uiEntry)
+    {
+        float Walk_Pos_X = 0.0f;
+        float Walk_Pos_Y = 0.0f;
+        float Walk_Pos_Z = 0.0f;
+
+        switch(rand()%6)
+        {
+            case 0:
+                Walk_Pos_X = ADDX_LEFT_FAR;
+                Walk_Pos_Y = ADDY_LEFT_FAR;
+                Walk_Pos_Z = ADDZ_LEFT_FAR;
+                break;
+            case 1:
+                Walk_Pos_X = ADDX_LEFT_MIDDLE;
+                Walk_Pos_Y = ADDY_LEFT_MIDDLE;
+                Walk_Pos_Z = ADDZ_LEFT_MIDDLE;
+                break;
+            case 2:
+                Walk_Pos_X = ADDX_LEFT_NEAR;
+                Walk_Pos_Y = ADDY_LEFT_NEAR;
+                Walk_Pos_Z = ADDZ_LEFT_NEAR;
+                break;
+            case 3:
+                Walk_Pos_X = ADDX_RIGHT_FAR;
+                Walk_Pos_Y = ADDY_RIGHT_FAR;
+                Walk_Pos_Z = ADDZ_RIGHT_FAR;
+                break;
+            case 4:
+                Walk_Pos_X = ADDX_RIGHT_MIDDLE;
+                Walk_Pos_Y = ADDY_RIGHT_MIDDLE;
+                Walk_Pos_Z = ADDZ_RIGHT_MIDDLE;
+                break;
+            case 5:
+                Walk_Pos_X = ADDX_RIGHT_NEAR;
+                Walk_Pos_Y = ADDY_RIGHT_NEAR;
+                Walk_Pos_Z = ADDZ_RIGHT_NEAR;
+                break;
+        }
+        if (Creature* pTemp = m_creature->SummonCreature(uiEntry, Walk_Pos_X-5 + rand()%10, Walk_Pos_Y-5 + rand()%10, Walk_Pos_Z, 0, TEMPSUMMON_TIMED_OR_CORPSE_DESPAWN, 300000))
+            m_lSummonsGUIDList.push_back(pTemp->GetGUID());
+    }
+
+    void DespawnSummons()
+    {
+        if (m_lSummonsGUIDList.empty())
+            return;
+
+        for(std::list<uint64>::iterator itr = m_lSummonsGUIDList.begin(); itr != m_lSummonsGUIDList.end(); ++itr)
+        {
+            if (Creature* pTemp = (Creature*)Unit::GetUnit(*m_creature, *itr))
+            {
+                if (pTemp->isAlive())
+                    pTemp->DealDamage(pTemp, pTemp->GetHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+            }
+        }
+
+        m_lSummonsGUIDList.clear();
+    }
+
     void UpdateAI(const uint32 diff)
     {
+        if (SendSummon)
+        {
+            if (Phase1Encounter_Timer < diff)
+            {
+                if (m_lSummonsGUIDList.empty())
+                    return;
+
+                if (m_uiSendSummon != m_lSummonsGUIDList.end())
+                {
+                    if (Creature* pTemp = (Creature*)Unit::GetUnit(*m_creature, *m_uiSendSummon))
+                        if (pTemp->isAlive() && !pTemp->getVictim())
+                            pTemp->GetMotionMaster()->MovePoint(0, WALKX_MIDDLE, WALKY_MIDDLE, WALKZ_MIDDLE);
+                    ++m_uiSendSummon;
+                    Phase1Encounter_Timer = 3000;
+                }
+                else
+                    SendSummon = false;
+
+            }else Phase1Encounter_Timer -= diff;
+        }
+
+        if (Phase1 && !Phase2)
+        {
+            if (Phase1_Timer < diff)
+            {
+                if (m_creature->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE))
+                    m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                AttackStart(m_creature->getVictim());
+                Phase1 = false;
+                Phase2 = true;
+                Phase1_Timer = 0;
+            }else Phase1_Timer -= diff;
+            return;
+        }
+
         if (!m_creature->SelectHostilTarget() || !m_creature->getVictim())
             return;
 
         //Check for Frost Bolt
         if (FrostBolt_Timer < diff)
         {
-            DoCast(m_creature->getVictim(),SPELL_FROST_BOLT);
+            if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,0))
+                DoCast(pTarget, m_bIsHeroic ? H_SPELL_FROST_BOLT : SPELL_FROST_BOLT);
             FrostBolt_Timer = (rand()%60)*1000;
         }else FrostBolt_Timer -= diff;
 
         //Check for Frost Bolt Nova
         if (FrostBoltNova_Timer < diff)
         {
-            DoCast(m_creature->getVictim(),SPELL_FROST_BOLT_NOVA);
+            DoCast(m_creature, m_bIsHeroic ? H_SPELL_FROST_BOLT_NOVA : SPELL_FROST_BOLT_NOVA);
             FrostBoltNova_Timer = 15000;
         }else FrostBoltNova_Timer -= diff;
 
@@ -315,7 +499,8 @@
         //Check for Mana Detonation
         if (ManaDetonation_Timer < diff)
         {
-            DoCast(m_creature->getVictim(),SPELL_MANA_DETONATION);
+            if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,1))
+                DoCast(pTarget,SPELL_MANA_DETONATION);
 
             if (rand()%2)
                 DoScriptText(SAY_SPECIAL1_MANA_DET, m_creature);
@@ -326,7 +511,8 @@
         //Check for Shadow Fissure
         if (ShadowFisure_Timer < diff)
         {
-            DoCast(m_creature->getVictim(),SPELL_SHADOW_FISURE);
+            if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,1))
+                DoCast(pTarget,SPELL_SHADOW_FISURE);
 
             if (rand()%2)
                 DoScriptText(SAY_SPECIAL3_MANA_DET, m_creature);
@@ -337,7 +523,8 @@
         //Check for Frost Blast
         if (FrostBlast_Timer < diff)
         {
-            DoCast(m_creature->getVictim(),SPELL_FROST_BLAST);
+            if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,1))
+                DoCast(pTarget,SPELL_FROST_BLAST);
 
             if (rand()%2)
                 DoScriptText(SAY_FROST_BLAST, m_creature);
@@ -355,7 +542,7 @@
             DoScriptText(SAY_ANSWER_REQUEST, m_creature);
         }
 
-        if (Phase3 && (GuardiansOfIcecrown_Count < 5))
+        if (Phase3 && (GuardiansOfIcecrown_Count < (m_bIsHeroic ? 4 : 2)))
         {
             if (GuardiansOfIcecrown_Timer < diff)
             {
@@ -370,42 +557,42 @@
                 switch(rand()%6)
                 {
                     case 0:
-                        pGuardian = m_creature->SummonCreature(16441,ADDX_LEFT_FAR,ADDY_LEFT_FAR,ADDZ_LEFT_FAR,ADDO_LEFT_FAR,TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT,1000);
+                        pGuardian = m_creature->SummonCreature(16441,ADDX_LEFT_FAR,ADDY_LEFT_FAR,ADDZ_LEFT_FAR,ADDO_LEFT_FAR,TEMPSUMMON_TIMED_OR_CORPSE_DESPAWN,300000);
                         //Setting walk position
                         Walk_Pos_X = WALKX_LEFT_FAR;
                         Walk_Pos_Y = WALKY_LEFT_FAR;
                         Walk_Pos_Z = WALKZ_LEFT_FAR;
                         break;
                     case 1:
-                        pGuardian = m_creature->SummonCreature(16441,ADDX_LEFT_MIDDLE,ADDY_LEFT_MIDDLE,ADDZ_LEFT_MIDDLE,ADDO_LEFT_MIDDLE,TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT,1000);
+                        pGuardian = m_creature->SummonCreature(16441,ADDX_LEFT_MIDDLE,ADDY_LEFT_MIDDLE,ADDZ_LEFT_MIDDLE,ADDO_LEFT_MIDDLE,TEMPSUMMON_TIMED_OR_CORPSE_DESPAWN,300000);
                         //Start moving guardian towards the center of the room
                         Walk_Pos_X = WALKX_LEFT_MIDDLE;
                         Walk_Pos_Y = WALKY_LEFT_MIDDLE;
                         Walk_Pos_Z = WALKZ_LEFT_MIDDLE;
                         break;
                     case 2:
-                        pGuardian = m_creature->SummonCreature(16441,ADDX_LEFT_NEAR,ADDY_LEFT_NEAR,ADDZ_LEFT_NEAR,ADDO_LEFT_NEAR,TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT,1000);
+                        pGuardian = m_creature->SummonCreature(16441,ADDX_LEFT_NEAR,ADDY_LEFT_NEAR,ADDZ_LEFT_NEAR,ADDO_LEFT_NEAR,TEMPSUMMON_TIMED_OR_CORPSE_DESPAWN,300000);
                         //Start moving guardian towards the center of the room
                         Walk_Pos_X = WALKX_LEFT_NEAR;
                         Walk_Pos_Y = WALKY_LEFT_NEAR;
                         Walk_Pos_Z = WALKZ_LEFT_NEAR;
                         break;
                     case 3:
-                        pGuardian = m_creature->SummonCreature(16441,ADDX_RIGHT_FAR,ADDY_RIGHT_FAR,ADDZ_RIGHT_FAR,ADDO_RIGHT_FAR,TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT,1000);
+                        pGuardian = m_creature->SummonCreature(16441,ADDX_RIGHT_FAR,ADDY_RIGHT_FAR,ADDZ_RIGHT_FAR,ADDO_RIGHT_FAR,TEMPSUMMON_TIMED_OR_CORPSE_DESPAWN,300000);
                         //Start moving guardian towards the center of the room
                         Walk_Pos_X = WALKX_RIGHT_FAR;
                         Walk_Pos_Y = WALKY_RIGHT_FAR;
                         Walk_Pos_Z = WALKZ_RIGHT_FAR;
                         break;
                     case 4:
-                        pGuardian = m_creature->SummonCreature(16441,ADDX_RIGHT_MIDDLE,ADDY_RIGHT_MIDDLE,ADDZ_RIGHT_MIDDLE,ADDO_RIGHT_MIDDLE,TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT,1000);
+                        pGuardian = m_creature->SummonCreature(16441,ADDX_RIGHT_MIDDLE,ADDY_RIGHT_MIDDLE,ADDZ_RIGHT_MIDDLE,ADDO_RIGHT_MIDDLE,TEMPSUMMON_TIMED_OR_CORPSE_DESPAWN,300000);
                         //Start moving guardian towards the center of the room
                         Walk_Pos_X = WALKX_RIGHT_MIDDLE;
                         Walk_Pos_Y = WALKY_RIGHT_MIDDLE;
                         Walk_Pos_Z = WALKZ_RIGHT_MIDDLE;
                         break;
                     case 5:
-                        pGuardian = m_creature->SummonCreature(16441,ADDX_RIGHT_NEAR,ADDY_RIGHT_NEAR,ADDZ_RIGHT_NEAR,ADDO_RIGHT_NEAR,TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT,1000);
+                        pGuardian = m_creature->SummonCreature(16441,ADDX_RIGHT_NEAR,ADDY_RIGHT_NEAR,ADDZ_RIGHT_NEAR,ADDO_RIGHT_NEAR,TEMPSUMMON_TIMED_OR_CORPSE_DESPAWN,300000);
                         //Start moving guardian towards the center of the room
                         Walk_Pos_X = WALKX_RIGHT_NEAR;
                         Walk_Pos_Y = WALKY_RIGHT_NEAR;
@@ -417,7 +604,8 @@
                 {
                     //if we find no one to figth walk to the center
                     if (!pGuardian->getVictim())
-                        pGuardian->SendMonsterMoveWithSpeed(Walk_Pos_X,Walk_Pos_Y,Walk_Pos_Z);
+                        //pGuardian->SendMonsterMoveWithSpeed(Walk_Pos_X,Walk_Pos_Y,Walk_Pos_Z);
+                        pGuardian->GetMotionMaster()->MovePoint(0, Walk_Pos_X, Walk_Pos_Y, Walk_Pos_Z);
 
                     //Safe storing of creatures
                     GuardiansOfIcecrown[GuardiansOfIcecrown_Count] = pGuardian->GetGUID();
@@ -431,15 +619,69 @@
             }else GuardiansOfIcecrown_Timer -= diff;
         }
 
+        if (m_creature->GetDistance2d(HOME_X, HOME_Y) > 80)
+            EnterEvadeMode();
+
         DoMeleeAttackIfReady();
     }
 };
 
+
+/*######
+## Mob Shadow Issure
+######*/
+
+struct MANGOS_DLL_DECL mob_shadow_issureAI : public ScriptedAI
+{
+    mob_shadow_issureAI(Creature *pCreature) : ScriptedAI(pCreature)
+    {
+        Reset();
+    }
+
+    uint32 m_uiShadowIssure_Timer;
+
+    void Reset()
+    {
+        m_uiShadowIssure_Timer = 4000;
+        m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        if (m_uiShadowIssure_Timer)
+            if (m_uiShadowIssure_Timer < uiDiff)
+            {
+                Map *map = m_creature->GetMap();
+                if (map->IsDungeon())
+                {
+                    Map::PlayerList const &PlayerList = map->GetPlayers();
+
+                    if (PlayerList.isEmpty())
+                        return;
+
+                    for (Map::PlayerList::const_iterator i = PlayerList.begin(); i != PlayerList.end(); ++i)
+                    {
+                        if (i->getSource()->isAlive() && m_creature->GetDistance2d(i->getSource()->GetPositionX(), i->getSource()->GetPositionY()) < 2)
+                            i->getSource()->DealDamage(i->getSource(), i->getSource()->GetHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+                    }
+                }
+                m_creature->DealDamage(m_creature, m_creature->GetHealth(), NULL, DIRECT_DAMAGE, SPELL_SCHOOL_MASK_NORMAL, NULL, false);
+                m_uiShadowIssure_Timer = 0;
+            }
+            else m_uiShadowIssure_Timer -= uiDiff;
+    }
+};
+
 CreatureAI* GetAI_boss_kelthuzadAI(Creature* pCreature)
 {
     return new boss_kelthuzadAI(pCreature);
 }
 
+CreatureAI* GetAI_mob_shadow_issureAI(Creature* pCreature)
+{
+    return new mob_shadow_issureAI(pCreature);
+}
+
 void AddSC_boss_kelthuzad()
 {
     Script *newscript;
@@ -447,4 +689,9 @@
     newscript->Name = "boss_kelthuzad";
     newscript->GetAI = &GetAI_boss_kelthuzadAI;
     newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "mob_shadow_issure";
+    newscript->GetAI = &GetAI_mob_shadow_issureAI;
+    newscript->RegisterSelf();
 }
Index: boss_loatheb.cpp
===================================================================
--- boss_loatheb.cpp	(revision 1388)
+++ boss_loatheb.cpp	(working copy)
@@ -22,12 +22,20 @@
 EndScriptData */
 
 #include "precompiled.h"
+#include "def_naxxramas.h"
 
-#define SPELL_CORRUPTED_MIND        29198
-#define SPELL_POISON_AURA           29865
+#define SPELL_DEATHBLOOM            29865
+#define SPELL_DEATHBLOOM_H          55053
 #define SPELL_INEVITABLE_DOOM       29204
-#define SPELL_REMOVE_CURSE          30281
+#define SPELL_INEVITABLE_DOOM_H     55052
+#define SPELL_BERSERK               26662
+#define SPELL_NECROTIC_AURA         55593
 
+#define SPELL_NECROTIC_AURA_PRE_WARNING 60929
+#define SPELL_NECROTIC_AURA_WARNING     59481
+
+#define SPELL_FUNGAL_CREEP          29232
+
 #define ADD_1X 2957.040
 #define ADD_1Y -3997.590
 #define ADD_1Z 274.280
@@ -42,43 +50,73 @@
 
 struct MANGOS_DLL_DECL boss_loathebAI : public ScriptedAI
 {
-    boss_loathebAI(Creature* pCreature) : ScriptedAI(pCreature) {Reset();}
+    boss_loathebAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsHeroicMode = pCreature->GetMap()->IsHeroic();
+        Reset();
+    }
+    ScriptedInstance* m_pInstance;
+    bool m_bIsHeroicMode;
 
-    uint32 CorruptedMind_Timer;
-    uint32 PoisonAura_Timer;
+    uint32 Deathbloom_Timer;
+    uint32 NecroticAura_Timer;
     uint32 InevitableDoom_Timer;
     uint32 InevitableDoom5mins_Timer;
-    uint32 RemoveCurse_Timer;
+    uint32 Enrage_Timer;
     uint32 Summon_Timer;
 
     void Reset()
     {
-        CorruptedMind_Timer = 4000;
-        PoisonAura_Timer = 2500;
+        Deathbloom_Timer = 30000;
+        NecroticAura_Timer = 2500;
         InevitableDoom_Timer = 120000;
-        InevitableDoom5mins_Timer = 300000;
-        RemoveCurse_Timer = 30000;
+        InevitableDoom5mins_Timer = 720000;
+        Enrage_Timer = 720000;
         Summon_Timer = 8000;
+
+        if(m_pInstance)
+            m_pInstance->SetData(TYPE_LOATHEB, NOT_STARTED);
     }
 
+    void Aggro(Unit *who)
+    {
+        if(m_pInstance)
+            m_pInstance->SetData(TYPE_LOATHEB, IN_PROGRESS);
+    }
+
+    void JustDied(Unit* Killer)
+    {
+        if(m_pInstance)
+            m_pInstance->SetData(TYPE_LOATHEB, DONE);
+    }
+
+    void JustSummoned(Creature* summoned)
+    {
+        if (Unit* target = SelectUnit(SELECT_TARGET_TOPAGGRO,0))
+            summoned->AI()->AttackStart(target);
+    }
+
     void UpdateAI(const uint32 diff)
     {
         if (!m_creature->SelectHostilTarget() || !m_creature->getVictim())
             return;
 
         //CorruptedMind_Timer
-        if (CorruptedMind_Timer < diff)
+        if (Deathbloom_Timer < diff)
         {
-            DoCast(m_creature->getVictim(),SPELL_CORRUPTED_MIND);
-            CorruptedMind_Timer = 62000;
-        }else CorruptedMind_Timer -= diff;
+            DoCast(SelectUnit(SELECT_TARGET_RANDOM,0), m_bIsHeroicMode ? SPELL_DEATHBLOOM_H : SPELL_DEATHBLOOM);
+            Deathbloom_Timer = 30000;
+        }else Deathbloom_Timer -= diff;
 
-        //PoisonAura_Timer
-        if (PoisonAura_Timer < diff)
+        //NecroticAura_Timer
+        if (NecroticAura_Timer < diff)
         {
-            DoCast(m_creature->getVictim(),SPELL_POISON_AURA);
-            PoisonAura_Timer = 60000;
-        }else PoisonAura_Timer -= diff;
+            DoCast(m_creature,SPELL_NECROTIC_AURA); // 17 seconds
+            //DoCast(m_creature,SPELL_NECROTIC_AURA_PRE_WARNING); // 14 seconds
+            //DoCast(m_creature,SPELL_NECROTIC_AURA_WARNING); // 17 seconds
+            NecroticAura_Timer = 20000;
+        }else NecroticAura_Timer -= diff;
 
         //InevitableDoom_Timer
         if (InevitableDoom_Timer < diff)
@@ -95,27 +133,20 @@
         }else InevitableDoom5mins_Timer -= diff;
 
         //RemoveCurse_Timer
-        if (RemoveCurse_Timer < diff)
+        if (Enrage_Timer < diff)
         {
-            DoCast(m_creature,SPELL_REMOVE_CURSE);
-            RemoveCurse_Timer = 30000;
-        }else RemoveCurse_Timer -= diff;
+            DoCast(m_creature,SPELL_BERSERK);
+            Enrage_Timer = 720000;
+        }else Enrage_Timer -= diff;
 
         //Summon_Timer
         if (Summon_Timer < diff)
         {
-            Unit* target = NULL;
             Unit* SummonedSpores = NULL;
 
             SummonedSpores = m_creature->SummonCreature(16286,ADD_1X,ADD_1Y,ADD_1Z,0,TEMPSUMMON_TIMED_OR_DEAD_DESPAWN,80000);
             SummonedSpores = m_creature->SummonCreature(16286,ADD_2X,ADD_2Y,ADD_2Z,0,TEMPSUMMON_TIMED_OR_DEAD_DESPAWN,80000);
             SummonedSpores = m_creature->SummonCreature(16286,ADD_3X,ADD_3Y,ADD_3Z,0,TEMPSUMMON_TIMED_OR_DEAD_DESPAWN,80000);
-            if (SummonedSpores)
-            {
-                target = SelectUnit(SELECT_TARGET_RANDOM,0);
-                if (target)
-                    SummonedSpores->AddThreat(target,1.0f);
-            }
 
             Summon_Timer = 28000;
         } else Summon_Timer -= diff;
@@ -123,16 +154,74 @@
         DoMeleeAttackIfReady();
     }
 };
+
+struct MANGOS_DLL_DECL npc_loatheb_sporesAI : public ScriptedAI
+{
+    npc_loatheb_sporesAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        Reset();
+    }
+
+    uint32 DieDelay_Timer;
+
+    void Reset()
+    {
+        DieDelay_Timer = 0;
+    }
+
+    void DamageTaken(Unit* done_by, uint32 &damage)
+    {
+        if (damage > m_creature->GetHealth() && !DieDelay_Timer)
+        {
+            m_creature->CastSpell(m_creature, SPELL_FUNGAL_CREEP, true);
+            DieDelay_Timer = 500;
+        }
+        if (DieDelay_Timer)
+        {
+            damage = 0;
+            return;
+        }
+    }
+
+    void JustDied(Unit* Killer) {}
+
+    void UpdateAI(const uint32 diff)
+    {
+        if (!m_creature->SelectHostilTarget() || !m_creature->getVictim())
+            return;
+
+        if (DieDelay_Timer)
+            if (DieDelay_Timer < diff)
+            {
+                m_creature->ForcedDespawn();
+                DieDelay_Timer = 0;
+            }else DieDelay_Timer -= diff;
+
+        DoMeleeAttackIfReady();
+    }
+};
+
 CreatureAI* GetAI_boss_loatheb(Creature* pCreature)
 {
     return new boss_loathebAI(pCreature);
 }
 
+CreatureAI* GetAI_npc_loatheb_spores(Creature* pCreature)
+{
+    return new npc_loatheb_sporesAI(pCreature);
+}
+
 void AddSC_boss_loatheb()
 {
     Script *newscript;
+
     newscript = new Script;
     newscript->Name = "boss_loatheb";
     newscript->GetAI = &GetAI_boss_loatheb;
     newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "npc_loatheb_spores";
+    newscript->GetAI = &GetAI_npc_loatheb_spores;
+    newscript->RegisterSelf();
 }
Index: boss_maexxna.cpp
===================================================================
--- boss_maexxna.cpp	(revision 1388)
+++ boss_maexxna.cpp	(working copy)
@@ -22,6 +22,7 @@
 EndScriptData */
 
 #include "precompiled.h"
+#include "def_naxxramas.h"
 
 #define SPELL_WEBTRAP           28622                       //Spell is normally used by the webtrap on the wall NOT by Maexxna
 
@@ -51,7 +52,10 @@
 
 struct MANGOS_DLL_DECL mob_webwrapAI : public ScriptedAI
 {
-    mob_webwrapAI(Creature* pCreature) : ScriptedAI(pCreature) {Reset();}
+    mob_webwrapAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        Reset();
+    }
 
     uint64 victimGUID;
 
@@ -60,36 +64,40 @@
         victimGUID = 0;
     }
 
-    void SetVictim(Unit* victim)
+    void AttackStart(Unit* pWho)
     {
+        return;
+    }
+
+    void SetVictim(uint64 victim)
+    {
         if (victim)
         {
-            victimGUID = victim->GetGUID();
-            victim->CastSpell(victim, SPELL_WEBTRAP, true);
+            victimGUID = victim;
+            if (Unit* pVictim = Unit::GetUnit((*m_creature), victimGUID))
+                pVictim->CastSpell(pVictim, SPELL_WEBTRAP, true);
         }
     }
 
-    void DamageTaken(Unit *done_by, uint32 &damage)
+    void JustDied(Unit* Killer)
     {
-        if (damage > m_creature->GetHealth())
-        {
-            if (victimGUID)
-            {
-                Unit* victim = NULL;
-                victim = Unit::GetUnit((*m_creature), victimGUID);
-                victim->RemoveAurasDueToSpell(SPELL_WEBTRAP);
-            }
-        }
+        if (Unit* pVictim = Unit::GetUnit((*m_creature), victimGUID))
+            pVictim->RemoveAurasDueToSpell(SPELL_WEBTRAP);
     }
-
-    void MoveInLineOfSight(Unit *who) { }
-    void UpdateAI(const uint32 diff) { }
 };
 
 struct MANGOS_DLL_DECL boss_maexxnaAI : public ScriptedAI
 {
-    boss_maexxnaAI(Creature* pCreature) : ScriptedAI(pCreature) {Reset();}
+    boss_maexxnaAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsHeroicMode = pCreature->GetMap()->IsHeroic();
+        Reset();
+    }
 
+    ScriptedInstance* m_pInstance;
+    bool m_bIsHeroicMode;
+
     uint32 WebTrap_Timer;
     uint32 WebSpray_Timer;
     uint32 PoisonShock_Timer;
@@ -105,58 +113,53 @@
         NecroticPoison_Timer = 30000;                       //30 seconds
         SummonSpiderling_Timer = 30000;                     //30 sec init, 40 sec normal
         Enraged = false;
+
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_MAEXXNA, NOT_STARTED);
     }
 
-    void DoCastWebWrap()
+    void JustDied(Unit* Killer)
     {
-        std::list<HostilReference *> t_list = m_creature->getThreatManager().getThreatList();
-        std::vector<Unit *> targets;
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_MAEXXNA, DONE);
+    }
 
-        //This spell doesn't work if we only have 1 player on threat list
-        if (t_list.size() < 2)
-            return;
+    void Aggro(Unit *who)
+    {
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_MAEXXNA, IN_PROGRESS);
+    }
 
-        //begin + 1 , so we don't target the one with the highest threat
-        std::list<HostilReference *>::iterator itr = t_list.begin();
-        std::advance(itr, 1);
-
-        //store the threat list in a different container
-        for(; itr!= t_list.end(); ++itr)
+    void DoCastWebWrap()
+    {
+        Unit* pWrapped = NULL;
+        for(uint8 i = 0; i < 2; ++i)
         {
-            Unit* target = Unit::GetUnit(*m_creature, (*itr)->getUnitGuid());
-
-            //only on alive players
-            if (target && target->isAlive() && target->GetTypeId() == TYPEID_PLAYER)
-                targets.push_back(target);
-        }
-
-        //cut down to size if we have more than 3 targets
-        while(targets.size() > 3)
-            targets.erase(targets.begin()+rand()%targets.size());
-
-        int i = 0;
-
-        for(std::vector<Unit *>::iterator iter = targets.begin(); iter!= targets.end(); ++iter, ++i)
-        {
-            // Teleport the 3 targets to a location on the wall and summon a Web Wrap on them
-            switch(i)
+            float LocX, LocY, LocZ;
+            switch(rand()%3)
             {
                 case 0:
-                    DoTeleportPlayer((*iter), LOC_X1, LOC_Y1, LOC_Z1, (*iter)->GetOrientation());
-                    if (Creature* pWrap = m_creature->SummonCreature(16486, LOC_X1, LOC_Y1, LOC_Z1, 0, TEMPSUMMON_TIMED_OR_DEAD_DESPAWN, 120000))
-                        ((mob_webwrapAI*)pWrap->AI())->SetVictim((*iter));
+                    LocX = LOC_X1 + rand()%5; LocY = LOC_Y1 + rand()%5; LocZ = LOC_Z1 + 1;
                     break;
                 case 1:
-                    DoTeleportPlayer((*iter), LOC_X2, LOC_Y2, LOC_Z2, (*iter)->GetOrientation());
-                    if (Creature* pWrap = m_creature->SummonCreature(16486, LOC_X2, LOC_Y2, LOC_Z2, 0, TEMPSUMMON_TIMED_OR_DEAD_DESPAWN, 120000))
-                        ((mob_webwrapAI*)pWrap->AI())->SetVictim((*iter));
+                    LocX = LOC_X2 + rand()%5; LocY = LOC_Y2 + rand()%5; LocZ = LOC_Z2 + 1;
                     break;
                 case 2:
-                    DoTeleportPlayer((*iter), LOC_X3, LOC_Y3, LOC_Z3, (*iter)->GetOrientation());
-                    if (Creature* pWrap = m_creature->SummonCreature(16486, LOC_X3, LOC_Y3, LOC_Z3, 0, TEMPSUMMON_TIMED_OR_DEAD_DESPAWN, 120000))
-                        ((mob_webwrapAI*)pWrap->AI())->SetVictim((*iter));
+                    LocX = LOC_X3 + rand()%5; LocY = LOC_Y3 + rand()%5; LocZ = LOC_Z3 + 1;
                     break;
             }
+
+            if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM,1))
+            {
+                if (pWrapped)
+                    if (pTarget == pWrapped)
+                         return;
+
+                DoTeleportPlayer(pTarget, LocX, LocY, LocZ, pTarget->GetOrientation());
+                if (Creature* pWrap = m_creature->SummonCreature(16486, LocX, LocY, LocZ, 0, TEMPSUMMON_TIMED_OR_DEAD_DESPAWN, 120000))
+                    ((mob_webwrapAI*)pWrap->AI())->SetVictim(pTarget->GetGUID());
+                pWrapped = pTarget;
+            }
         }
     }
 
@@ -175,21 +178,21 @@
         //WebSpray_Timer
         if (WebSpray_Timer < diff)
         {
-            DoCast(m_creature->getVictim(), SPELL_WEBSPRAY);
+            DoCast(m_creature->getVictim(), m_bIsHeroicMode ? H_SPELL_WEBSPRAY : SPELL_WEBSPRAY);
             WebSpray_Timer = 40000;
         }else WebSpray_Timer -= diff;
 
         //PoisonShock_Timer
         if (PoisonShock_Timer < diff)
         {
-            DoCast(m_creature->getVictim(), SPELL_POISONSHOCK);
+            DoCast(m_creature->getVictim(), m_bIsHeroicMode ? H_SPELL_POISONSHOCK : SPELL_POISONSHOCK);
             PoisonShock_Timer = 20000;
         }else PoisonShock_Timer -= diff;
 
         //NecroticPoison_Timer
         if (NecroticPoison_Timer < diff)
         {
-            DoCast(m_creature->getVictim(), SPELL_NECROTICPOISON);
+            DoCast(m_creature->getVictim(), m_bIsHeroicMode ? H_SPELL_NECROTICPOISON : SPELL_NECROTICPOISON);
             NecroticPoison_Timer = 30000;
         }else NecroticPoison_Timer -= diff;
 
@@ -203,7 +206,7 @@
         //Enrage if not already enraged and below 30%
         if (!Enraged && (m_creature->GetHealth()*100 / m_creature->GetMaxHealth()) < 30)
         {
-            DoCast(m_creature,SPELL_FRENZY);
+            DoCast(m_creature, m_bIsHeroicMode ? H_SPELL_FRENZY : SPELL_FRENZY);
             Enraged = true;
         }
 
Index: boss_noth.cpp
===================================================================
--- boss_noth.cpp	(revision 1388)
+++ boss_noth.cpp	(working copy)
@@ -22,6 +22,7 @@
 EndScriptData */
 
 #include "precompiled.h"
+#include "def_naxxramas.h"
 
 enum
 {
@@ -43,7 +44,8 @@
     SPELL_SUMMON_GUARDIAN_AND_CONSTRUCT = 29269,
 
     NPC_PLAGUED_WARRIOR                 = 16984,
-
+    NPC_PLAGUED_CHAMPIONS               = 16983,
+    NPC_PLAGUED_GUARDIANS               = 16981,
 };
 
 uint32 m_auiSpellSummonPlaguedWarrior[]=
@@ -82,15 +84,37 @@
     ScriptedInstance* m_pInstance;
     bool m_bIsHeroicMode;
 
+    bool isTeleported;
+
+    uint8 SecondPhaseCounter;
+
     uint32 Blink_Timer;
     uint32 Curse_Timer;
     uint32 Summon_Timer;
+    uint32 SecondPhase_Timer;
+    uint32 Teleport_Timer;
 
+    float LastX, LastY, LastZ;
+
     void Reset()
     {
+        isTeleported = false;
+        SecondPhaseCounter = 0;
         Blink_Timer = 25000;
         Curse_Timer = 4000;
-        Summon_Timer = 12000;
+        Summon_Timer = 30000;
+        SecondPhase_Timer = 17000;
+        Teleport_Timer = 120000;
+
+        LastX = 0;
+        LastY = 0;
+        LastZ = 0;
+
+        m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+        m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+
+        if(m_pInstance)
+            m_pInstance->SetData(TYPE_NOTH, NOT_STARTED);
     }
 
     void Aggro(Unit *who)
@@ -101,12 +125,39 @@
             case 1: DoScriptText(SAY_AGGRO2, m_creature); break;
             case 2: DoScriptText(SAY_AGGRO3, m_creature); break;
         }
+
+        if (!who || m_creature->getVictim())
+            return;
+
+        if (who->isTargetableForAttack() && who->isInAccessablePlaceFor(m_creature) && m_creature->IsHostileTo(who))
+            AttackStart(who);
+
+        if(m_pInstance)
+            m_pInstance->SetData(TYPE_NOTH, IN_PROGRESS);
     }
 
+    void AttackStart(Unit* who)
+    {
+        if (isTeleported)
+            return;
+
+        if (!who || who == m_creature)
+            return;
+
+        if (m_creature->Attack(who, true))
+        {
+            m_creature->SetInCombatWithZone();
+            DoStartMovement(who);
+        }
+    }
+
     void JustSummoned(Creature* summoned)
     {
         if (Unit* target = SelectUnit(SELECT_TARGET_RANDOM,0))
+        {
             summoned->AddThreat(target,0.0f);
+            summoned->AI()->AttackStart(target);
+        }
     }
 
     void KilledUnit(Unit* victim)
@@ -121,19 +172,63 @@
     void JustDied(Unit* Killer)
     {
         DoScriptText(SAY_DEATH, m_creature);
+
+        if(m_pInstance)
+            m_pInstance->SetData(TYPE_NOTH, DONE);
     }
 
     void UpdateAI(const uint32 diff)
     {
+        if (isTeleported)
+        {
+            if (Teleport_Timer < diff)
+            {
+                m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+                m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                m_creature->GetMap()->CreatureRelocation(m_creature, LastX, LastY, LastZ, 0);
+                m_creature->SendMonsterMove(LastX, LastY, LastZ, 0, MONSTER_MOVE_NONE, 0);
+                DoStartMovement(m_creature->getVictim());
+                LastX = 0;
+                LastY = 0;
+                LastZ = 0;
+                isTeleported = false;
+                Teleport_Timer = 120000;
+            }else Teleport_Timer -= diff;
+
+            if (SecondPhase_Timer < diff)
+            {
+                switch (SecondPhaseCounter)
+                {
+                    case 0:
+                        for(uint8 i = 0; i < (m_bIsHeroicMode ? 4 : 2); i++)
+                            m_creature->SummonCreature(NPC_PLAGUED_CHAMPIONS,2684.804,-3502.517,261.313,0,TEMPSUMMON_TIMED_OR_DEAD_DESPAWN,80000);
+                        break;
+                    case 1:
+                    case 2:
+                        for(uint8 i = 0; i < (m_bIsHeroicMode ? 4 : 2) - (m_bIsHeroicMode ? 2 : 1); i++)
+                            m_creature->SummonCreature(NPC_PLAGUED_CHAMPIONS,2684.804,-3502.517,261.313,0,TEMPSUMMON_TIMED_OR_DEAD_DESPAWN,80000);
+                        for(uint8 i = 0; i < (m_bIsHeroicMode ? 2 : 1); i++)
+                            m_creature->SummonCreature(NPC_PLAGUED_GUARDIANS,2684.804,-3502.517,261.313,0,TEMPSUMMON_TIMED_OR_DEAD_DESPAWN,80000);
+                        break;
+                }
+                SecondPhaseCounter ++;
+                SecondPhase_Timer = 22000;
+            } else SecondPhase_Timer -= diff;
+            return;
+        }
+
         if (!m_creature->SelectHostilTarget() || !m_creature->getVictim())
             return;
 
         //Blink_Timer
         if (Blink_Timer < diff)
         {
-            DoCast(m_creature->getVictim(),SPELL_CRIPPLE);
-            DoCast(m_creature,SPELL_BLINK);
-
+            DoCast(m_creature->getVictim(), m_bIsHeroicMode ? SPELL_CRIPPLE_H : SPELL_CRIPPLE);
+            //DoCast(m_creature, SPELL_BLINK);
+            m_creature->GetMap()->CreatureRelocation(m_creature, 2670.804 + rand()%30, -3517.517 + rand()%30, 261.313, m_creature->GetOrientation());
+            DoResetThreat();
+            if (Unit* pTarget = SelectUnit(SELECT_TARGET_RANDOM, 0))
+                AttackStart(pTarget);
             Blink_Timer = 25000;
         }else Blink_Timer -= diff;
 
@@ -149,12 +244,32 @@
         {
             DoScriptText(SAY_SUMMON, m_creature);
 
-            for(uint8 i = 0; i < 6; ++i)
-                m_creature->SummonCreature(NPC_PLAGUED_WARRIOR,2684.804,-3502.517,261.313,0,TEMPSUMMON_TIMED_OR_DEAD_DESPAWN,80000);
+            for(uint8 i = 0; i < (m_bIsHeroicMode ? 3 : 2); ++i)
+                m_creature->SummonCreature(NPC_PLAGUED_WARRIOR, 2672.804 + rand()%15,-3509.517 + rand()%15, 261.313, 0, TEMPSUMMON_TIMED_OR_DEAD_DESPAWN, 80000);
 
-            Summon_Timer = 30500;
+            Summon_Timer = 30000;
         } else Summon_Timer -= diff;
 
+        if (Teleport_Timer < diff)
+        {
+            m_creature->InterruptNonMeleeSpells(true);
+            LastX = m_creature->GetPositionX();
+            LastY = m_creature->GetPositionY();
+            LastZ = m_creature->GetPositionZ();
+            m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE);
+            m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+            m_creature->StopMoving();
+            m_creature->GetMotionMaster()->Clear(false);
+            m_creature->GetMotionMaster()->MoveIdle();
+            m_creature->GetMap()->CreatureRelocation(m_creature, TELE_X, TELE_Y, TELE_Z, TELE_O);
+            m_creature->SendMonsterMove(TELE_X, TELE_Y, TELE_Z, TELE_O, MONSTER_MOVE_NONE, 0);
+            isTeleported = true;
+            SecondPhaseCounter = 0;
+            SecondPhase_Timer = 0;
+            Teleport_Timer = 70000;
+            return;
+        }else Teleport_Timer -= diff;
+
         DoMeleeAttackIfReady();
     }
 };
Index: boss_patchwerk.cpp
===================================================================
--- boss_patchwerk.cpp	(revision 1388)
+++ boss_patchwerk.cpp	(working copy)
@@ -22,6 +22,7 @@
 EndScriptData */
 
 #include "precompiled.h"
+#include "def_naxxramas.h"
 
 #define SAY_AGGRO1              -1533017
 #define SAY_AGGRO2              -1533018
@@ -39,8 +40,14 @@
 
 struct MANGOS_DLL_DECL boss_patchwerkAI : public ScriptedAI
 {
-    boss_patchwerkAI(Creature* pCreature) : ScriptedAI(pCreature) {Reset();}
+    boss_patchwerkAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        Reset();
+    }
 
+    ScriptedInstance* m_pInstance;
+
     uint32 HatefullStrike_Timer;
     uint32 Enrage_Timer;
     uint32 Slimebolt_Timer;
@@ -52,6 +59,9 @@
         Enrage_Timer = 420000;                              //7 minutes 420,000
         Slimebolt_Timer = 450000;                           //7.5 minutes 450,000
         Enraged = false;
+
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_PATCHWERK, NOT_STARTED);
     }
 
     void KilledUnit(Unit* Victim)
@@ -65,6 +75,9 @@
     void JustDied(Unit* Killer)
     {
         DoScriptText(SAY_DEATH, m_creature);
+
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_PATCHWERK, DONE);
     }
 
     void Aggro(Unit *who)
@@ -73,6 +86,9 @@
             DoScriptText(SAY_AGGRO1, m_creature);
         else
             DoScriptText(SAY_AGGRO2, m_creature);
+
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_PATCHWERK, IN_PROGRESS);
     }
 
     void UpdateAI(const uint32 diff)
@@ -103,7 +119,7 @@
             if (pMostHPTarget)
                 DoCast(pMostHPTarget, SPELL_HATEFULSTRIKE);
 
-            HatefullStrike_Timer = 1200;
+            HatefullStrike_Timer = 3000;
         }else HatefullStrike_Timer -= diff;
 
         //Enrage_Timer
Index: boss_razuvious.cpp
===================================================================
--- boss_razuvious.cpp	(revision 1388)
+++ boss_razuvious.cpp	(working copy)
@@ -22,6 +22,7 @@
 EndScriptData */
 
 #include "precompiled.h"
+#include "def_naxxramas.h"
 
 //Razuvious - NO TEXT sound only
 //8852 aggro01 - Hah hah, I'm just getting warmed up!
@@ -50,13 +51,27 @@
 #define SOUND_DEATH     8860
 #define SOUND_AGGROMIX  8847
 
-#define SPELL_UNBALANCINGSTRIKE     26613
-#define SPELL_DISRUPTINGSHOUT       29107
+#define SPELL_UNBALANCING_STRIKE     55470
+#define SPELL_DISRUPTING_SHOUT       55543
+#define SPELL_HOPELESS               29125
+#define SPELL_JAGGED_KNIFE           55550
 
+#define NPC_DEATH_KNIGHT_UNDERSTUDY  16803
+
 struct MANGOS_DLL_DECL boss_razuviousAI : public ScriptedAI
 {
-    boss_razuviousAI(Creature* pCreature) : ScriptedAI(pCreature) {Reset();}
+    boss_razuviousAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsHeroicMode = pCreature->GetMap()->IsHeroic();
+        Reset();
+    }
 
+    ScriptedInstance* m_pInstance;
+    bool m_bIsHeroicMode;
+
+    std::list<uint64> DeathKnightList;
+
     uint32 UnbalancingStrike_Timer;
     uint32 DisruptingShout_Timer;
     uint32 CommandSound_Timer;
@@ -66,6 +81,9 @@
         UnbalancingStrike_Timer = 30000;                    //30 seconds
         DisruptingShout_Timer = 25000;                      //25 seconds
         CommandSound_Timer = 40000;                         //40 seconds
+
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_RAZUVIOUS, NOT_STARTED);
     }
 
     void KilledUnit(Unit* Victim)
@@ -87,6 +105,22 @@
     void JustDied(Unit* Killer)
     {
         DoPlaySoundToSet(m_creature, SOUND_DEATH);
+
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_RAZUVIOUS, DONE);
+
+        if (!DeathKnightList.empty())
+        {
+            for(std::list<uint64>::iterator itr = DeathKnightList.begin(); itr != DeathKnightList.end(); ++itr)
+            {
+                Creature* pDeathKnight = NULL;
+                pDeathKnight = ((Creature*)Unit::GetUnit(*m_creature, *itr));
+
+                if (pDeathKnight)
+                    if (pDeathKnight->isAlive())
+                        pDeathKnight->CastSpell(pDeathKnight, SPELL_HOPELESS, true);
+            }
+        }
     }
 
     void Aggro(Unit *who)
@@ -103,6 +137,28 @@
                 DoPlaySoundToSet(m_creature, SOUND_AGGRO3);
                 break;
         }
+
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_RAZUVIOUS, IN_PROGRESS);
+
+        FindDeathKnight();
+
+        if (!DeathKnightList.empty())
+        {
+            for(std::list<uint64>::iterator itr = DeathKnightList.begin(); itr != DeathKnightList.end(); ++itr)
+            {
+                if (Creature* pDeathKnight = ((Creature*)Unit::GetUnit(*m_creature, *itr)))
+                {
+                    if (pDeathKnight->isDead())
+                    {
+                        pDeathKnight->RemoveCorpse();
+                        pDeathKnight->Respawn();
+                    }
+
+                    pDeathKnight->AI()->AttackStart(who);
+                }
+            }
+        }
     }
 
     void UpdateAI(const uint32 diff)
@@ -113,14 +169,14 @@
         //UnbalancingStrike_Timer
         if (UnbalancingStrike_Timer < diff)
         {
-            DoCast(m_creature->getVictim(),SPELL_UNBALANCINGSTRIKE);
+            DoCast(m_creature->getVictim(),SPELL_UNBALANCING_STRIKE);
             UnbalancingStrike_Timer = 30000;
         }else UnbalancingStrike_Timer -= diff;
 
         //DisruptingShout_Timer
         if (DisruptingShout_Timer < diff)
         {
-            DoCast(m_creature->getVictim(), SPELL_DISRUPTINGSHOUT);
+            DoCast(m_creature->getVictim(), SPELL_DISRUPTING_SHOUT);
             DisruptingShout_Timer = 25000;
         }else DisruptingShout_Timer -= diff;
 
@@ -151,7 +207,23 @@
 
         DoMeleeAttackIfReady();
     }
+
+    void FindDeathKnight()
+    {
+        std::list<Creature*> DeathKnight;
+        GetCreatureListWithEntryInGrid(DeathKnight, m_creature, NPC_DEATH_KNIGHT_UNDERSTUDY, 50.0f);
+
+        if (!DeathKnight.empty())
+        {
+            DeathKnightList.clear();
+
+            for(std::list<Creature*>::iterator itr = DeathKnight.begin(); itr != DeathKnight.end(); ++itr)
+                DeathKnightList.push_back((*itr)->GetGUID());
+        }
+    }
+
 };
+
 CreatureAI* GetAI_boss_razuvious(Creature* pCreature)
 {
     return new boss_razuviousAI(pCreature);
Index: boss_sapphiron.cpp
===================================================================
--- boss_sapphiron.cpp	(revision 1388)
+++ boss_sapphiron.cpp	(working copy)
@@ -22,24 +22,40 @@
 EndScriptData */
 
 #include "precompiled.h"
+#include "def_naxxramas.h"
 
 #define EMOTE_BREATH            -1533082
 #define EMOTE_ENRAGE            -1533083
 
 #define SPELL_ICEBOLT           28522
 #define SPELL_FROST_BREATH      29318
+#define SPELL_FROST_BREATH_H    28524
 #define SPELL_FROST_AURA        28531
 #define SPELL_LIFE_DRAIN        28542
+#define SPELL_LIFE_DRAIN_H      55665
 #define SPELL_BLIZZARD          28547
 #define SPELL_BESERK            26662
+#define SPELL_ICEBOLT_VISUAL    45776
+#define SPELL_CLEAVE            19983
+#define SPELL_TAIL_LASH         55697
+#define SPELL_TAIL_LASH_H       55696
 
+#define SAPPHIRON_X             3522
+#define SAPPHIRON_Y             -5236
+#define SAPPHIRON_Z             137
+
 struct MANGOS_DLL_DECL boss_sapphironAI : public ScriptedAI
 {
     boss_sapphironAI(Creature* pCreature) : ScriptedAI(pCreature)
     {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsHeroicMode = pCreature->GetMap()->IsHeroic();
         Reset();
     }
 
+    ScriptedInstance *m_pInstance;
+    bool m_bIsHeroicMode;
+
     uint32 Icebolt_Count;
     uint32 Icebolt_Timer;
     uint32 FrostBreath_Timer;
@@ -48,9 +64,12 @@
     uint32 Blizzard_Timer;
     uint32 Fly_Timer;
     uint32 Beserk_Timer;
+    uint32 m_uiCleaveTimer;
+    uint32 m_uiTailSweepTimer;
     uint32 phase;
     bool landoff;
     uint32 land_Timer;
+    std::vector<Unit*> targets;
 
     void Reset()
     {
@@ -61,14 +80,99 @@
         Fly_Timer = 45000;
         Icebolt_Timer = 4000;
         land_Timer = 2000;
-        Beserk_Timer = 0;
+        Beserk_Timer = 900000;
+        m_uiCleaveTimer = 7000;
+        m_uiTailSweepTimer = 20000;
         phase = 1;
         Icebolt_Count = 0;
         landoff = false;
 
+        targets.clear();
+
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_SAPPHIRON, NOT_STARTED);
         //m_creature->ApplySpellMod(SPELL_FROST_AURA, SPELLMOD_DURATION, -1);
     }
 
+    void Aggro(Unit* who)
+    {
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_SAPPHIRON, IN_PROGRESS);
+    }
+
+    void MoveInLineOfSight(Unit* who)
+    {
+        if (!who)
+            return;
+
+        if (who->isTargetableForAttack() && who->GetTypeId() == TYPEID_PLAYER)
+        {
+            if (m_pInstance)
+            {
+                if (m_pInstance->GetData(TYPE_SAPPHIRON) == NOT_STARTED)
+                {
+                    if (m_pInstance->GetData(TYPE_THADDIUS) == DONE && m_pInstance->GetData(TYPE_MAEXXNA) == DONE &&
+                        m_pInstance->GetData(TYPE_FOUR_HORSEMEN) == DONE && m_pInstance->GetData(TYPE_LOATHEB) == DONE)
+                    {
+                        if (m_creature->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE))
+                            m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                    }
+                    else
+                    {
+                        if (!m_creature->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE))
+                            m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+                    }
+                }
+            }
+        }
+    }
+
+    void SpellHitTarget(Unit *target, const SpellEntry *spell)
+    {
+        if(spell->Id == SPELL_ICEBOLT)
+        {
+                    if (target->isAlive() && target->HasAura(SPELL_ICEBOLT))
+                    {
+                        target->CastSpell(target, 62766, true);
+                        target->ApplySpellImmune(0, IMMUNITY_SCHOOL, SPELL_SCHOOL_MASK_FROST, true);
+                    }
+
+/*            for(std::vector<Unit*>::iterator itr = targets.begin(); itr!= targets.end(); ++itr)
+            {
+                if (*itr)
+                {
+                    if (target->isAlive() && (*itr)->GetGUID() == target->GetGUID() && !((*itr)->HasAura(SPELL_ICEBOLT)))
+                    {
+                        target->CastSpell(target, 62766, true);
+                        target->ApplySpellImmune(0, IMMUNITY_SCHOOL, SPELL_SCHOOL_MASK_FROST, true);
+                    }
+            	}
+            }
+*/
+            return;
+        }
+
+        if(spell->Id == SPELL_FROST_BREATH)
+        {
+            if (target->GetTypeId() != TYPEID_PLAYER)
+                return;
+
+            if (target->HasAura(SPELL_ICEBOLT))
+            {
+                target->RemoveAurasDueToSpell(62766);
+                target->RemoveAurasDueToSpell(SPELL_ICEBOLT);
+                target->ApplySpellImmune(0, IMMUNITY_SCHOOL, SPELL_SCHOOL_MASK_FROST, false);
+                return;
+            }
+        }
+    }
+
+    void JustDied(Unit* pKiller)
+    {
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_SAPPHIRON, DONE);
+    }
+
     void UpdateAI(const uint32 diff)
     {
         if (!m_creature->SelectHostilTarget() || !m_creature->getVictim())
@@ -85,7 +189,7 @@
             if (LifeDrain_Timer < diff)
             {
                 if (Unit* target = SelectUnit(SELECT_TARGET_RANDOM,0))
-                    DoCast(target,SPELL_LIFE_DRAIN);
+                    DoCast(target, m_bIsHeroicMode ? SPELL_LIFE_DRAIN_H : SPELL_LIFE_DRAIN);
 
                 LifeDrain_Timer = 24000;
             }else LifeDrain_Timer -= diff;
@@ -98,6 +202,24 @@
                 Blizzard_Timer = 20000;
             }else Blizzard_Timer -= diff;
 
+            // Cleave
+            if (m_uiCleaveTimer < diff)
+            {
+                DoCast(m_creature->getVictim(), SPELL_CLEAVE);
+                m_uiCleaveTimer = 7000 + rand()%3000;
+            }
+            else
+                m_uiCleaveTimer -= diff;
+
+            // Tail Sweep
+            if (m_uiTailSweepTimer < diff)
+            {
+                DoCast(m_creature->getVictim(), m_bIsHeroicMode ? SPELL_TAIL_LASH_H : SPELL_TAIL_LASH);
+                m_uiTailSweepTimer = 15000 + rand()%5000;
+            }
+            else
+                m_uiTailSweepTimer -= diff;
+
             if (m_creature->GetHealth()*100 / m_creature->GetMaxHealth() > 10)
             {
                 if (Fly_Timer < diff)
@@ -105,11 +227,14 @@
                     phase = 2;
                     m_creature->InterruptNonMeleeSpells(false);
                     m_creature->HandleEmoteCommand(EMOTE_ONESHOT_LIFTOFF);
+                    m_creature->StopMoving();
                     m_creature->GetMotionMaster()->Clear(false);
                     m_creature->GetMotionMaster()->MoveIdle();
-                    DoCast(m_creature,11010);
-                    m_creature->SetHover(true);
-                    DoCast(m_creature,18430);
+                    m_creature->GetMap()->CreatureRelocation(m_creature, SAPPHIRON_X, SAPPHIRON_Y, SAPPHIRON_Z + 20, m_creature->GetOrientation());
+                    m_creature->SendMonsterMove(SAPPHIRON_X, SAPPHIRON_Y, SAPPHIRON_Z + 20, 0, m_creature->GetMonsterMoveFlags(), 1);
+                    //DoCast(m_creature,11010);
+                    //m_creature->SetHover(true);
+                    //DoCast(m_creature,18430);
                     Icebolt_Timer = 4000;
                     Icebolt_Count = 0;
                     landoff = false;
@@ -121,8 +246,12 @@
         {
             if (Icebolt_Timer < diff && Icebolt_Count < 5)
             {
-                if (Unit* target = SelectUnit(SELECT_TARGET_RANDOM,0))
-                    DoCast(target,SPELL_ICEBOLT);
+                if (Icebolt_Count == 1 || Icebolt_Count == 3)
+                    if (Unit* target = SelectUnit(SELECT_TARGET_RANDOM,0))
+                    {
+                        DoCast(target, SPELL_ICEBOLT);
+                        targets.push_back(target);
+                    }
 
                 ++Icebolt_Count;
                 Icebolt_Timer = 4000;
@@ -132,6 +261,27 @@
             {
                 if (FrostBreath_Timer < diff)
                 {
+                    // apply immune
+                    std::list<HostilReference*>::iterator i = m_creature->getThreatManager().getThreatList().begin();
+                    for (i = m_creature->getThreatManager().getThreatList().begin(); i!= m_creature->getThreatManager().getThreatList().end();++i)
+                    {
+                        Unit* pUnit = Unit::GetUnit((*m_creature), (*i)->getUnitGuid());
+                        if (pUnit && (pUnit->GetTypeId() == TYPEID_PLAYER))
+                        {
+                            if (!pUnit->HasAura(SPELL_ICEBOLT))
+                            {
+                                for(std::vector<Unit*>::iterator itr = targets.begin(); itr!= targets.end(); ++itr)
+                                {
+                                    if (*itr)
+                                    {
+                                        if (pUnit->GetDistance2d(*itr) <= 5 && (*itr)->HasAura(SPELL_ICEBOLT))
+                                            pUnit->ApplySpellImmune(0, IMMUNITY_SCHOOL, SPELL_SCHOOL_MASK_FROST, true);
+                                    }
+                                }
+                            }
+                        }
+                    }
+
                     DoScriptText(EMOTE_BREATH, m_creature);
                     DoCast(m_creature->getVictim(),SPELL_FROST_BREATH);
                     land_Timer = 2000;
@@ -146,23 +296,31 @@
                 {
                     phase = 1;
                     m_creature->HandleEmoteCommand(EMOTE_ONESHOT_LAND);
-                    m_creature->SetHover(false);
-                    m_creature->GetMotionMaster()->Clear(false);
-                    m_creature->GetMotionMaster()->MoveChase(m_creature->getVictim());
+                    //m_creature->SetHover(false);
+                    //m_creature->GetMotionMaster()->Clear(false);
+                    //m_creature->GetMotionMaster()->MoveChase(m_creature->getVictim());
+                    DoStartMovement(m_creature->getVictim());
+
+                    std::list<HostilReference*>::iterator i = m_creature->getThreatManager().getThreatList().begin();
+                    for (i = m_creature->getThreatManager().getThreatList().begin(); i!= m_creature->getThreatManager().getThreatList().end();++i)
+                    {
+                        Unit* pUnit = Unit::GetUnit((*m_creature), (*i)->getUnitGuid());
+                        if (pUnit && (pUnit->GetTypeId() == TYPEID_PLAYER))
+                            pUnit->ApplySpellImmune(0, IMMUNITY_SCHOOL, SPELL_SCHOOL_MASK_FROST, false);
+                    }
+
+                    targets.clear();
                     Fly_Timer = 67000;
                 }else land_Timer -= diff;
             }
         }
 
-        if ((m_creature->GetHealth()*100) / m_creature->GetMaxHealth() <= 10)
+        if (Beserk_Timer < diff)
         {
-            if (Beserk_Timer < diff)
-            {
-                DoScriptText(EMOTE_ENRAGE, m_creature);
-                DoCast(m_creature,SPELL_BESERK);
-                Beserk_Timer = 300000;
-            }else Beserk_Timer -= diff;
-        }
+            DoScriptText(EMOTE_ENRAGE, m_creature);
+            DoCast(m_creature,SPELL_BESERK);
+            Beserk_Timer = 900000;
+        }else Beserk_Timer -= diff;
 
         if (phase!=2)
             DoMeleeAttackIfReady();
Index: boss_thaddius.cpp
===================================================================
--- boss_thaddius.cpp	(revision 1388)
+++ boss_thaddius.cpp	(working copy)
@@ -16,37 +16,40 @@
 
 /* ScriptData
 SDName: Boss_Thaddius
+SDAuthor: ckegg
 SD%Complete: 0
 SDComment: Placeholder. Includes Feugen & Stalagg.
 SDCategory: Naxxramas
 EndScriptData */
 
 #include "precompiled.h"
+#include "def_naxxramas.h"
 
 //Stalagg
 #define SAY_STAL_AGGRO          -1533023
 #define SAY_STAL_SLAY           -1533024
 #define SAY_STAL_DEATH          -1533025
+#define SPELL_POWERSURGE           28134
+#define H_SPELL_POWERSURGE         54529
 
-#define SPELL_POWERSURGE        28134
-
 //Feugen
 #define SAY_FEUG_AGGRO          -1533026
 #define SAY_FEUG_SLAY           -1533027
 #define SAY_FEUG_DEATH          -1533028
+#define SPELL_STATICFIELD          28135
+#define H_SPELL_STATICFIELD        54528
 
-#define SPELL_MANABURN          28135
-
 //both
-#define SPELL_WARSTOMP          28125
+#define SPELL_WARSTOMP             28125
+#define SPELL_MAGNETIC_PULL        28338 // 54517?
+#define SPELL_MAGNETIC_PULL_VISUAL 28337
 
 //Thaddus
-#define SAY_GREET               -1533029
-#define SAY_AGGRO1              -1533030
-#define SAY_AGGRO2              -1533031
-#define SAY_AGGRO3              -1533032
-#define SAY_SLAY                -1533033
-#define SAY_ELECT               -1533034
+#define SAY_AGGRO               -1533029
+#define SAY_KILL1               -1533031
+#define SAY_KILL2               -1533032
+#define SAY_KILL3               -1533033
+#define SAY_KILL4               -1533034
 #define SAY_DEATH               -1533035
 #define SAY_SCREAM1             -1533036
 #define SAY_SCREAM2             -1533037
@@ -55,11 +58,11 @@
 
 #define SPELL_BALL_LIGHTNING                28299
 
+#define SPELL_POLARITY_SHIFT                28089
 #define SPELL_CHARGE_POSITIVE_DMGBUFF       29659
-#define SPELL_CHARGE_POSITIVE_NEARDMG       28059
-
+#define SPELL_CHARGE_POSITIVE_NEARDMG       28059 // *
 #define SPELL_CHARGE_NEGATIVE_DMGBUFF       29660
-#define SPELL_CHARGE_NEGATIVE_NEARDMG       28084
+#define SPELL_CHARGE_NEGATIVE_NEARDMG       28084 // *
 
 #define SPELL_CHAIN_LIGHTNING               28167
 #define H_SPELL_CHAIN_LIGHTNING             54531
@@ -68,3 +71,622 @@
 
 //generic
 #define C_TESLA_COIL                        16218           //the coils (emotes "Tesla Coil overloads!")
+
+
+struct MANGOS_DLL_DECL mob_stalaggAI : public ScriptedAI
+{
+    mob_stalaggAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsHeroicMode = pCreature->GetMap()->IsHeroic();
+        Reset();
+    }
+
+    ScriptedInstance* m_pInstance;
+    bool m_bIsHeroicMode;
+    bool m_bIsDeath;
+    bool m_bIsHold;
+
+    float HomeX, HomeY, HomeZ;
+
+    uint32 WarStomp_Timer;
+    uint32 PowerSurge_Timer;
+    uint32 DeathCheck_Timer;
+    uint32 Hold_Timer;
+
+    void Reset()
+    {
+    	m_bIsDeath = false;
+    	m_bIsHold = false;
+
+        HomeX = 3450.45;
+        HomeY = -2931.42;
+        HomeZ = 312.091;
+
+        WarStomp_Timer = 8000+rand()%2000;
+        PowerSurge_Timer = 10000+rand()%5000;
+        DeathCheck_Timer = 1000;
+        Hold_Timer = 3000;
+    }
+
+    void Aggro(Unit* pWho)
+    {
+        DoScriptText(SAY_STAL_AGGRO, m_creature);
+    }
+
+    void SetHold()
+    {
+        m_creature->StopMoving();
+        m_creature->GetMotionMaster()->Clear(false);
+        m_creature->GetMotionMaster()->MoveIdle();
+        Hold_Timer = 3000;
+        m_bIsHold = true;
+    }
+
+    void AttackStart(Unit* pWho)
+    {
+        if (m_bIsHold)
+            return;
+
+        if (m_creature->Attack(pWho, true))
+        {
+            m_creature->AddThreat(pWho, 0.0f);
+            m_creature->SetInCombatWith(pWho);
+            pWho->SetInCombatWith(m_creature);
+            DoStartMovement(pWho);
+        }
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        if (!m_creature->SelectHostilTarget() || !m_creature->getVictim())
+            return;
+
+        if (m_bIsHold)
+        {
+            if (Hold_Timer < uiDiff)
+            {
+                m_creature->AI()->AttackStart(m_creature->getVictim());
+                DoStartMovement(m_creature->getVictim());
+                m_bIsHold = false;
+            }else Hold_Timer -= uiDiff;
+        }
+
+        if (DeathCheck_Timer < uiDiff)
+        {
+            if (m_pInstance)
+                if (Creature* pFeugen = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_FEUGEN))))
+                {
+                    if (!pFeugen->isAlive() && !m_bIsDeath)
+                    {
+                        m_bIsDeath = true;
+                        DeathCheck_Timer = 5000;
+                    }
+                    else if (!pFeugen->isAlive() && m_bIsDeath)
+                    {
+                        pFeugen->Respawn();
+                        m_bIsDeath = false;
+                        DeathCheck_Timer = 1000;
+                    }
+                    else
+                        DeathCheck_Timer = 1000;
+                }
+        }else DeathCheck_Timer -= uiDiff;
+
+        if (WarStomp_Timer < uiDiff)
+        {
+            DoCast(m_creature, SPELL_WARSTOMP);
+            WarStomp_Timer = 8000+rand()%2000;
+        }else WarStomp_Timer -= uiDiff;
+
+        if (PowerSurge_Timer < uiDiff)
+        {
+            DoCast(m_creature, m_bIsHeroicMode ? H_SPELL_POWERSURGE : SPELL_POWERSURGE);
+            PowerSurge_Timer = 10000+rand()%5000;
+        }else PowerSurge_Timer -= uiDiff;
+
+/*
+        if (m_creature->GetDistance2d(HomeX, HomeY) > 10)
+            DoCast(m_creature, SPELL_WARSTOMP);
+*/
+        DoMeleeAttackIfReady();
+    }
+
+    void KilledUnit(Unit *victim)
+    {
+        if(victim == m_creature)
+            return;
+        DoScriptText(SAY_STAL_SLAY, m_creature);
+    }
+    void JustDied(Unit* killer)
+    {
+        DoScriptText(SAY_STAL_DEATH, m_creature);
+    }
+};
+
+struct MANGOS_DLL_DECL mob_feugenAI : public ScriptedAI
+{
+    mob_feugenAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsHeroicMode = pCreature->GetMap()->IsHeroic();
+        Reset();
+    }
+
+    ScriptedInstance* m_pInstance;
+    bool m_bIsHeroicMode;
+    bool m_bIsDeath;
+    bool m_bIsHold;
+
+    float HomeX, HomeY, HomeZ;
+
+    uint32 WarStomp_Timer;
+    uint32 StaticField_Timer;
+    uint32 DeathCheck_Timer;
+    uint32 Hold_Timer;
+
+    void Reset()
+    {
+        m_bIsDeath = false;
+        m_bIsHold = false;
+
+        HomeX = 3508.14;
+        HomeY = -2988.65;
+        HomeZ = 312.092;
+
+        WarStomp_Timer = 8000+rand()%2000;
+        StaticField_Timer = 10000+rand()%5000;
+        DeathCheck_Timer = 1000;
+        Hold_Timer = 3000;
+    }
+
+    void Aggro(Unit* pWho)
+    {
+        DoScriptText(SAY_FEUG_AGGRO, m_creature);
+    }
+
+    void SetHold()
+    {
+        m_creature->StopMoving();
+        m_creature->GetMotionMaster()->Clear(false);
+        m_creature->GetMotionMaster()->MoveIdle();
+        Hold_Timer = 3000;
+        m_bIsHold = true;
+    }
+
+    void AttackStart(Unit* pWho)
+    {
+        if (m_bIsHold)
+            return;
+
+        if (m_creature->Attack(pWho, true))
+        {
+            m_creature->AddThreat(pWho, 0.0f);
+            m_creature->SetInCombatWith(pWho);
+            pWho->SetInCombatWith(m_creature);
+            DoStartMovement(pWho);
+        }
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        if (!m_creature->SelectHostilTarget() || !m_creature->getVictim())
+            return;
+
+        if (m_bIsHold)
+        {
+            if (Hold_Timer < uiDiff)
+            {
+                m_creature->AI()->AttackStart(m_creature->getVictim());
+                DoStartMovement(m_creature->getVictim());
+                m_bIsHold = false;
+            }else Hold_Timer -= uiDiff;
+        }
+
+        if (DeathCheck_Timer < uiDiff)
+        {
+            if (m_pInstance)
+                if (Creature* pStalagg = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_STALAGG))))
+                {
+                    if (!pStalagg->isAlive() && !m_bIsDeath)
+                    {
+                        m_bIsDeath = true;
+                        DeathCheck_Timer = 5000;
+                    }
+                    else if (!pStalagg->isAlive() && m_bIsDeath)
+                    {
+                        pStalagg->Respawn();
+                        m_bIsDeath = false;
+                        DeathCheck_Timer = 1000;
+                    }
+                    else
+                        DeathCheck_Timer = 1000;
+                }
+        }else DeathCheck_Timer -= uiDiff;
+
+        if (WarStomp_Timer < uiDiff)
+        {
+            DoCast(m_creature, SPELL_WARSTOMP);
+            WarStomp_Timer = 8000+rand()%2000;
+        }else WarStomp_Timer -= uiDiff;
+
+        if (StaticField_Timer < uiDiff)
+        {
+            DoCast(m_creature, m_bIsHeroicMode ? H_SPELL_STATICFIELD : SPELL_STATICFIELD);
+            StaticField_Timer = 10000+rand()%5000;
+        }else StaticField_Timer -= uiDiff;
+
+/*
+        if (m_creature->GetDistance2d(HomeX, HomeY) > 10)
+            DoCast(m_creature, SPELL_WARSTOMP);
+*/
+        DoMeleeAttackIfReady();
+    }
+
+    void KilledUnit(Unit *victim)
+    {
+        if(victim == m_creature)
+            return;
+        DoScriptText(SAY_FEUG_SLAY, m_creature);
+    }
+    void JustDied(Unit* killer)
+    {
+        DoScriptText(SAY_FEUG_DEATH, m_creature);
+    }
+};
+
+struct MANGOS_DLL_DECL boss_thaddiusAI : public ScriptedAI
+{
+    boss_thaddiusAI(Creature* pCreature) : ScriptedAI(pCreature)
+    {
+        m_pInstance = (ScriptedInstance*)pCreature->GetInstanceData();
+        m_bIsHeroicMode = pCreature->GetMap()->IsHeroic();
+        Reset();
+    }
+
+    ScriptedInstance* m_pInstance;
+    bool m_bIsHeroicMode;
+    bool m_bIsActiveCheck;
+    bool m_bIsActived;
+    bool m_bIsPolarityShift;
+    bool m_bInMeleeRange;
+
+    uint32 Active_Timer;
+    uint32 ChainLightning_Timer;
+    uint32 PolarityShift_Timer;
+    uint32 BallLightning_Timer;
+    uint32 Enrage_Timer;
+    uint32 Scream_Timer;
+    uint32 RangeCheck_Timer;
+
+    uint32 SwitchTarget_Timer;
+
+    void Reset()
+    {
+        m_bIsActiveCheck = false;
+        m_bIsActived = false;
+        m_bIsPolarityShift = false;
+        m_bInMeleeRange = false;
+
+        Active_Timer = 1000;
+        ChainLightning_Timer = 15000;
+        PolarityShift_Timer = 30000;
+        BallLightning_Timer = 1000;
+        Enrage_Timer = 300000;
+        Scream_Timer = 60000+rand()%30000;
+        RangeCheck_Timer = 2000;
+
+        SwitchTarget_Timer = 20000;
+
+        m_creature->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+
+        if (m_pInstance)
+        {
+            if (Creature* pStalagg = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_STALAGG))))
+                if (!pStalagg->isAlive())
+                    pStalagg->Respawn();
+
+            if (Creature* pFeugen = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_FEUGEN))))
+                if (!pFeugen->isAlive())
+                    pFeugen->Respawn();
+
+            m_pInstance->SetData(TYPE_THADDIUS, NOT_STARTED);
+        }
+    }
+
+    void Aggro(Unit* who)
+    {
+        DoScriptText(SAY_AGGRO, m_creature);
+
+        if (!who || m_creature->getVictim())
+            return;
+
+        if (who->isTargetableForAttack() && who->isInAccessablePlaceFor(m_creature) && m_creature->IsHostileTo(who))
+            AttackStart(who);
+
+        if(m_pInstance)
+            m_pInstance->SetData(TYPE_THADDIUS, IN_PROGRESS);
+    }
+
+    void AttackStart(Unit* who)
+    {
+        if (!m_bIsActived)
+            return;
+
+        if (!who || who == m_creature)
+            return;
+
+        if (m_creature->Attack(who, true))
+        {
+            m_creature->SetInCombatWithZone();
+            m_creature->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE);
+            DoStartMovement(who);
+        }
+    }
+
+    void UpdateAI(const uint32 uiDiff)
+    {
+        if (m_bIsActiveCheck)
+        {
+            if (!m_bIsActived && Active_Timer < uiDiff)
+            {
+                m_bIsActived = true;
+                Active_Timer = 1000;
+            }else Active_Timer -= uiDiff;
+        }
+        else
+        {
+            if (Active_Timer < uiDiff)
+            {
+                if(m_pInstance)
+                {
+                    bool m_bIsAlive = false;
+                    Creature* pStalagg;
+                    Creature* pFeugen;
+                    if (pStalagg = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_STALAGG))))
+                        if (pStalagg->isAlive())
+                            m_bIsAlive = true;
+                    if (pFeugen = ((Creature*)Unit::GetUnit((*m_creature), m_pInstance->GetData64(DATA_FEUGEN))))
+                        if (pFeugen->isAlive())
+                            m_bIsAlive = true;
+
+                    if (!m_bIsAlive)
+                    {
+                        m_bIsActiveCheck = true;
+                        Active_Timer = 15000;
+                    }
+                    else
+                    {
+                        if (pStalagg->isInCombat() && pFeugen->isInCombat())
+                        {
+                            if (SwitchTarget_Timer < uiDiff)
+                            {
+                                Unit* pStalaggTarget;
+                                Unit* pFeugenTarget;
+                                float StalaggTargetThreat;
+                                float FeugenTargetThreat;
+
+                                // Get Stalagg's target threat
+                                if (pStalagg && pStalagg->isAlive())
+                                {
+                                    if (pStalaggTarget = pStalagg->getVictim())
+                                        StalaggTargetThreat = m_creature->getThreatManager().getThreat(pStalaggTarget);
+                                }
+                                // Get Feugen's target threat
+                                if (pFeugen && pFeugen->isAlive())
+                                {
+                                    if (pFeugenTarget = pFeugen->getVictim())
+                                        FeugenTargetThreat = m_creature->getThreatManager().getThreat(pFeugenTarget);
+                                }
+
+                                // Switch Feugen's target from Stalagg
+                                if (pStalagg && pStalagg->isAlive())
+                                {
+                                    if (pFeugen && pFeugen->isAlive())
+                                    {
+                                        HostilReference* ref = pFeugen->getThreatManager().getOnlineContainer().getReferenceByTarget(pFeugenTarget);
+                                        if (ref)
+                                        {
+                                            ((mob_stalaggAI*)pStalagg->AI())->SetHold();
+                                            pStalagg->CastSpell(pFeugenTarget, 54517, true);
+                                            ((Player*)pFeugenTarget)->TeleportTo(pFeugenTarget->GetMapId(), pStalagg->GetPositionX(), pStalagg->GetPositionY(), pStalagg->GetPositionZ(), 0, TELE_TO_NOT_LEAVE_COMBAT);
+                                            ref->removeReference();
+                                            pStalagg->AddThreat(pFeugenTarget, FeugenTargetThreat);
+                                            //pStalagg->AI()->AttackStart(pFeugenTarget);
+                                        }
+                                    }
+                                }
+                                // Switch Stalagg's target from Feugen
+                                if (pFeugen && pFeugen->isAlive())
+                                {
+                                    if (pStalagg && pStalagg->isAlive())
+                                    {
+                                        HostilReference* ref = pStalagg->getThreatManager().getOnlineContainer().getReferenceByTarget(pStalaggTarget);
+                                        if (ref)
+                                        {
+                                            ((mob_feugenAI*)pFeugen->AI())->SetHold();
+                                            pFeugen->CastSpell(pStalaggTarget, 54517, true);
+                                            ((Player*)pStalaggTarget)->TeleportTo(pStalaggTarget->GetMapId(), pFeugen->GetPositionX(), pFeugen->GetPositionY(), pFeugen->GetPositionZ(), 0, TELE_TO_NOT_LEAVE_COMBAT);
+                                            ref->removeReference();
+                                            pFeugen->AddThreat(pStalaggTarget, StalaggTargetThreat);
+                                            //pFeugen->AI()->AttackStart(pStalaggTarget);
+                                        }
+                                    }
+                                }
+
+                                SwitchTarget_Timer = 20000;
+                            }else SwitchTarget_Timer -= uiDiff;
+                        }
+                        else if (pStalagg->isInCombat() || pFeugen->isInCombat())
+                        {
+                            if (m_pInstance)
+                                m_pInstance->SetData(TYPE_THADDIUS, IN_PROGRESS);
+                        }
+                        else if (!pStalagg->isInCombat() && !pFeugen->isInCombat())
+                        {
+                            if (m_pInstance)
+                                m_pInstance->SetData(TYPE_THADDIUS, NOT_STARTED);
+                        }
+
+                        Active_Timer = 1000;
+                    }
+                }
+            }else Active_Timer -= uiDiff;
+        }
+
+        if (!m_creature->SelectHostilTarget() || !m_creature->getVictim())
+            return;
+
+        if (ChainLightning_Timer < uiDiff)
+        {
+            DoCast(m_creature, m_bIsHeroicMode ? H_SPELL_CHAIN_LIGHTNING : SPELL_CHAIN_LIGHTNING);
+            ChainLightning_Timer = 12000+rand()%5000;
+        }else ChainLightning_Timer -= uiDiff;
+
+        if(m_bIsPolarityShift)
+        {
+            // workaround for POLARITY_SHIFT
+            if (PolarityShift_Timer < uiDiff)
+            {
+/*
+                Map *map = m_creature->GetMap();
+                if (map->IsDungeon())
+                {
+                    Map::PlayerList const &PlayerList = map->GetPlayers();
+
+                    if (PlayerList.isEmpty())
+                        return;
+
+                    for (Map::PlayerList::const_iterator i = PlayerList.begin(); i != PlayerList.end(); ++i)
+                        if (i->getSource()->isAlive() && i->getSource()->isTargetableForAttack())
+                        {
+                            switch(rand()%2)
+                            {
+                                case 0:
+                                    if (i->getSource()->HasAura(SPELL_CHARGE_NEGATIVE_NEARDMG))
+                                        i->getSource()->RemoveAurasDueToSpell(SPELL_CHARGE_NEGATIVE_NEARDMG);
+                                    i->getSource()->CastSpell(i->getSource(), SPELL_CHARGE_POSITIVE_NEARDMG, true);
+                                    break;
+                                case 1:
+                                    if (i->getSource()->HasAura(SPELL_CHARGE_POSITIVE_NEARDMG))
+                                        i->getSource()->RemoveAurasDueToSpell(SPELL_CHARGE_POSITIVE_NEARDMG);
+                                    i->getSource()->CastSpell(i->getSource(), SPELL_CHARGE_NEGATIVE_NEARDMG, true);
+                                    break;
+                            }
+                        }
+                }
+*/
+                m_bIsPolarityShift = false;
+                PolarityShift_Timer = 27000;
+            }else PolarityShift_Timer -= uiDiff;
+        }
+        else
+        {
+            if(PolarityShift_Timer < uiDiff)
+            {
+      	        DoCast(m_creature, SPELL_POLARITY_SHIFT); // need core support
+                m_bIsPolarityShift = true;
+                PolarityShift_Timer = 3000;
+            }else PolarityShift_Timer -= uiDiff;
+        }
+
+        if (Enrage_Timer < uiDiff)
+        {
+            DoCast(m_creature, SPELL_BESERK);
+            Enrage_Timer = 300000;
+        }else Enrage_Timer -= uiDiff;
+
+        if (Scream_Timer < uiDiff)
+        {
+            switch(rand()%4)
+            {
+                case 0: DoScriptText(SAY_SCREAM1, m_creature);break;
+                case 1: DoScriptText(SAY_SCREAM2, m_creature);break;
+                case 2: DoScriptText(SAY_SCREAM3, m_creature);break;
+                case 3: DoScriptText(SAY_SCREAM4, m_creature);break;
+            }
+            Scream_Timer = 60000+rand()%30000;
+        }else Scream_Timer -= uiDiff;
+
+        if (RangeCheck_Timer < uiDiff)
+        {
+            m_bInMeleeRange = false;
+            std::list<HostilReference *> t_list = m_creature->getThreatManager().getThreatList();
+            for(std::list<HostilReference *>::iterator itr = t_list.begin(); itr!= t_list.end(); ++itr)
+            {
+                Unit* pTarget = Unit::GetUnit(*m_creature, (*itr)->getUnitGuid());
+
+                //if in melee range
+                if (pTarget && pTarget->IsWithinDistInMap(m_creature, ATTACK_DISTANCE))
+                {
+                    m_bInMeleeRange = true;
+                    break;
+                }
+            }
+
+            if (!m_bInMeleeRange)
+                DoCast(SelectUnit(SELECT_TARGET_TOPAGGRO,0), SPELL_BALL_LIGHTNING);
+
+            RangeCheck_Timer = 2000;
+        }else RangeCheck_Timer -= uiDiff;
+
+        //if nobody is in melee range
+        if (m_bInMeleeRange)
+            DoMeleeAttackIfReady();
+    }
+
+    void JustDied(Unit* killer)
+    {
+        DoScriptText(SAY_DEATH, m_creature);
+
+        if (m_pInstance)
+            m_pInstance->SetData(TYPE_THADDIUS, DONE);
+    }
+
+    void KilledUnit(Unit *victim)
+    {
+        if(victim == m_creature)
+            return;
+        switch(rand()%4)
+        {
+            case 0: DoScriptText(SAY_KILL1, m_creature);break;
+            case 1: DoScriptText(SAY_KILL2, m_creature);break;
+            case 2: DoScriptText(SAY_KILL3, m_creature);break;
+            case 3: DoScriptText(SAY_KILL4, m_creature);break;
+        }
+    }
+};
+
+CreatureAI* GetAI_boss_thaddius(Creature* pCreature)
+{
+    return new boss_thaddiusAI(pCreature);
+}
+
+CreatureAI* GetAI_mob_stalagg(Creature* pCreature)
+{
+    return new mob_stalaggAI(pCreature);
+}
+
+CreatureAI* GetAI_mob_feugen(Creature* pCreature)
+{
+    return new mob_feugenAI(pCreature);
+}
+
+void AddSC_boss_thaddius()
+{
+    Script *newscript;
+    newscript = new Script;
+    newscript->Name = "boss_thaddius";
+    newscript->GetAI = &GetAI_boss_thaddius;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "mob_stalagg";
+    newscript->GetAI = &GetAI_mob_stalagg;
+    newscript->RegisterSelf();
+
+    newscript = new Script;
+    newscript->Name = "mob_feugen";
+    newscript->GetAI = &GetAI_mob_feugen;
+    newscript->RegisterSelf();
+}
Index: def_naxxramas.h
===================================================================
--- def_naxxramas.h	(revision 0)
+++ def_naxxramas.h	(revision 0)
@@ -0,0 +1,98 @@
+
+#ifndef DEF_NAXXRAMAS_H
+#define DEF_NAXXRAMAS_H
+
+enum Data
+{
+    MAX_ENCOUNTER               = 15,
+
+    TYPE_PATCHWERK              = 1,
+    TYPE_GROBBULUS              = 2,
+    TYPE_GLUTH                  = 3,
+    TYPE_THADDIUS               = 4,
+    TYPE_STALAGG                = 5,
+    TYPE_FEUGEN                 = 6,
+
+    TYPE_ANUB_REKHAN            = 10,
+    TYPE_FAERLINA               = 11,
+    TYPE_MAEXXNA                = 12,
+
+    TYPE_RAZUVIOUS              = 13,
+    TYPE_GOTHIK                 = 14,
+    TYPE_FOUR_HORSEMEN          = 15,
+
+    TYPE_NOTH                   = 16,
+    TYPE_HEIGAN                 = 17,
+    TYPE_LOATHEB                = 18,
+
+    TYPE_SAPPHIRON              = 19,
+    TYPE_KELTHUZAD              = 20,
+
+    DATA_ANUB_REKHAN            = 30,
+    DATA_FAERLINA               = 31,
+    DATA_GOTHIK_GATE            = 32,
+
+    DATA_THADDIUS               = 33,
+    DATA_STALAGG                = 34,
+    DATA_FEUGEN                 = 35,
+
+    DATA_KORTHAZZ               = 36,
+    DATA_RIVENDARE              = 37,
+    DATA_BLAUMEUX               = 38,
+    DATA_ZELIEK                 = 39,
+
+    NPC_ZELIEK                  = 16063,
+    NPC_THANE                   = 16064,
+    NPC_BLAUMEUX                = 16065,
+    NPC_RIVENDARE               = 30549,
+
+    NPC_ANUB_REKHAN             = 15956,
+    NPC_FAERLINA                = 15953,
+
+    NPC_THADDIUS                = 15928,
+    NPC_STALAGG                 = 15929,
+    NPC_FEUGEN                  = 15930,
+
+    GO_ARAC_ANUB_GATE           = 181195,                   //open when anub dead?
+    GO_ARAC_ANUB_DOOR           = 181126,                   //encounter door
+    GO_ARAC_FAER_WEB            = 181235,                   //encounter door
+    GO_ARAC_DOOD_DOOR_2         = 181235,                   //after faerlina, to outer ring
+    GO_ARAC_FAER_DOOR           = 194022,                   //encounter door
+    GO_ARAC_MAEX_OUTER_DOOR     = 181209,                   //right before maex
+    GO_ARAC_MAEX_INNER_DOOR     = 181197,                   //encounter door
+    GO_ARAC_EYE_RAMP            = 181212,
+    GO_ARAC_PORTAL              = 181575,
+
+    GO_PLAG_SLIME01_DOOR        = 181198,
+    GO_PLAG_SLIME02_DOOR        = 181199,
+    GO_PLAG_NOTH_ENTRY_DOOR     = 181200,                   //encounter door
+    GO_PLAG_NOTH_EXIT_DOOR      = 181201,                   //exit, open when boss dead
+    GO_PLAG_HEIG_ENTRY_DOOR     = 181202,
+    GO_PLAG_HEIG_EXIT_DOOR      = 181203,                   //exit, open when boss dead
+    GO_PLAG_LOAT_DOOR           = 181241,                   //encounter door
+    GO_PLAG_EYE_RAMP            = 181211,
+    GO_PLAG_PORTAL              = 181577,
+
+    GO_MILI_GOTH_ENTRY_GATE     = 181124,
+    GO_MILI_GOTH_EXIT_GATE      = 181125,
+    GO_MILI_GOTH_COMBAT_GATE    = 181170,                   //encounter door (?)
+    GO_MILI_HORSEMEN_DOOR       = 181119,                   //encounter door
+    GO_MILI_EYE_RAMP            = 181210,                   //encounter door
+    GO_MILI_PORTAL              = 181578,                   //encounter door
+
+    GO_CHEST_HORSEMEN_NORM      = 181366,                   //four horsemen event, DoRespawnGameObject() when event == DONE
+    GO_CHEST_HORSEMEN_HERO      = 193426,
+
+    GO_CONS_PATH_EXIT_DOOR      = 181123,
+    GO_CONS_GLUT_EXIT_DOOR      = 181120,                   //encounter door (?)
+    GO_CONS_THAD_DOOR           = 181121,
+    GO_CONS_EYE_RAMP            = 181213,
+    GO_CONS_PORTAL              = 181576,
+
+    GO_KELTHUZAD_WATERFALL_DOOR = 181225,
+
+    AREATRIGGER_FROSTWYRM       = 4120,                     //not needed here, but AT to be scripted
+};
+
+#endif
+
Index: instance_naxxramas.cpp
===================================================================
--- instance_naxxramas.cpp	(revision 1388)
+++ instance_naxxramas.cpp	(working copy)
@@ -22,83 +22,557 @@
 EndScriptData */
 
 #include "precompiled.h"
+#include "def_naxxramas.h"
 
-enum
+/* Encounters
+0 Patchwerk
+1 Grobbulus
+2 Gluth
+3 Thaddius
+4 Anub'Rekhan
+5 Grand Widow Faerlina
+6 Maexxna
+7 Instructor Razuvious
+8 Gothik the Harvester
+9 Four Horsemen
+10 Noth the Plaguebringer
+11 Heigan the Unclean
+12 Loatheb
+13 Sapphiron
+14 Kel'Thuzad
+*/
+
+struct MANGOS_DLL_DECL instance_naxxramas : public ScriptedInstance
 {
-    MAX_ENCOUNTER               = 1,
+    instance_naxxramas(Map* pMap) : ScriptedInstance(pMap) {Initialize();};
 
-    GO_ARAC_ANUB_GATE           = 181195,                   //open when anub dead?
-    GO_ARAC_ANUB_DOOR           = 181126,                   //encounter door
-    GO_ARAC_FAER_WEB            = 181235,                   //encounter door
-    GO_ARAC_DOOD_DOOR_2         = 181235,                   //after faerlina, to outer ring
-    GO_ARAC_MAEX_OUTER_DOOR     = 181209,                   //right before maex
-    GO_ARAC_MAEX_INNER_DOOR     = 181197,                   //encounter door
+    uint32 m_auiEncounter[MAX_ENCOUNTER];
+    std::string strInstData;
 
-    GO_PLAG_SLIME01_DOOR        = 181198,
-    GO_PLAG_SLIME02_DOOR        = 181199,
-    GO_PLAG_NOTH_ENTRY_DOOR     = 181200,                   //encounter door
-    GO_PLAG_NOTH_EXIT_DOOR      = 181201,                   //exit, open when boss dead
-    GO_PLAG_HEIG_ENTRY_DOOR     = 181202,
-    GO_PLAG_HEIG_EXIT_DOOR      = 181203,                   //exit, open when boss dead
-    GO_PLAG_LOAT_DOOR           = 181241,                   //encounter door
+    uint64 m_uiAracEyeRampGUID;
+    uint64 m_uiPlagEyeRampGUID;
+    uint64 m_uiMiliEyeRampGUID;
+    uint64 m_uiConsEyeRampGUID;
 
-    GO_MILI_GOTH_ENTRY_GATE     = 181124,
-    GO_MILI_GOTH_EXIT_GATE      = 181125,
-    GO_MILI_GOTH_COMBAT_GATE    = 181170,                   //encounter door (?)
-    GO_MILI_HORSEMEN_DOOR       = 181119,                   //encounter door
+    uint64 m_uiAracPortalGUID;
+    uint64 m_uiPlagPortalGUID;
+    uint64 m_uiMiliPortalGUID;
+    uint64 m_uiConsPortalGUID;
 
-    GO_CHEST_HORSEMEN_NORM      = 181366,                   //four horsemen event, DoRespawnGameObject() when event == DONE
-    GO_CHEST_HORSEMEN_HERO      = 193426,
+    uint64 m_uiThaddiusGUID;
+    uint64 m_uiStalaggGUID;
+    uint64 m_uiFeugenGUID;
 
-    GO_CONS_PATH_EXIT_DOOR      = 181123,
-    GO_CONS_GLUT_EXIT_DOOR      = 181120,                   //encounter door (?)
-    GO_CONS_THAD_DOOR           = 181121,
+    uint64 m_uiAnubRekhanGUID;
+    uint64 m_uiFaerlinanGUID;
 
-    NPC_ZELIEK                  = 16063,
-    NPC_THANE                   = 16064,
-    NPC_BLAUMEUX                = 16065,
-    NPC_RIVENDARE               = 30549,
+    uint64 m_uiZeliekGUID;
+    uint64 m_uiThaneGUID;
+    uint64 m_uiBlaumeuxGUID;
+    uint64 m_uiRivendareGUID;
 
-    NPC_THADDIUS                = 15928,
-    NPC_STALAGG                 = 15929,
-    NPC_FEUGEN                  = 15930,
+    uint64 m_uiPathExitDoorGUID;
+    uint64 m_uiGlutExitDoorGUID;
+    uint64 m_uiThadDoorGUID;
 
-    AREATRIGGER_FROSTWYRM       = 4120                      //not needed here, but AT to be scripted
-};
+    uint64 m_uiAnubDoorGUID;
+    uint64 m_uiAnubGateGUID;
+    uint64 m_uiFaerDoorGUID;
+    uint64 m_uiMaexOuterGUID;
+    uint64 m_uiMaexInnerGUID;
 
-struct MANGOS_DLL_DECL instance_naxxramas : public ScriptedInstance
-{
-    instance_naxxramas(Map* pMap) : ScriptedInstance(pMap) {Initialize();}
+    uint64 m_uiGothCombatGateGUID;
+    uint64 m_uiGothikEntryDoorGUID;
+    uint64 m_uiGothikExitDoorGUID;
+    uint64 m_uiHorsemenDoorGUID;
+    uint64 m_uiHorsemenChestNGUID;
 
-    std::string strInstData;
-    uint32 m_auiEncounter[MAX_ENCOUNTER];
+    uint64 m_uiNothEntryDoorGUID;
+    uint64 m_uiNothExitDoorGUID;
+    uint64 m_uiHeigEntryDoorGUID;
+    uint64 m_uiHeigExitDoorGUID;
+    uint64 m_uiLoathebDoorGUID;
 
+    uint64 m_uiKelthuzadDoorGUID;
+
     void Initialize()
     {
         memset(&m_auiEncounter, 0, sizeof(m_auiEncounter));
+
+        m_uiAracEyeRampGUID = 0;
+        m_uiPlagEyeRampGUID = 0;
+        m_uiMiliEyeRampGUID = 0;
+        m_uiConsEyeRampGUID = 0;
+
+        m_uiAracPortalGUID = 0;
+        m_uiPlagPortalGUID = 0;
+        m_uiMiliPortalGUID = 0;
+        m_uiConsPortalGUID = 0;
+
+        m_uiThaddiusGUID  = 0;
+        m_uiStalaggGUID   = 0;
+        m_uiFeugenGUID    = 0;
+
+        m_uiAnubRekhanGUID = 0;
+        m_uiFaerlinanGUID  = 0;
+
+        m_uiZeliekGUID     = 0;
+        m_uiThaneGUID      = 0;
+        m_uiBlaumeuxGUID   = 0;
+        m_uiRivendareGUID  = 0;
+
+        m_uiPathExitDoorGUID = 0;
+        m_uiGlutExitDoorGUID = 0;
+        m_uiThadDoorGUID     = 0;
+
+        m_uiAnubDoorGUID     = 0;
+        m_uiAnubGateGUID     = 0;
+        m_uiFaerDoorGUID     = 0;
+        m_uiMaexOuterGUID    = 0;
+        m_uiMaexInnerGUID    = 0;
+
+        m_uiGothCombatGateGUID  = 0;
+        m_uiGothikEntryDoorGUID = 0;
+        m_uiGothikExitDoorGUID  = 0;
+        m_uiHorsemenDoorGUID    = 0;
+        m_uiHorsemenChestNGUID  = 0;
+
+        m_uiNothEntryDoorGUID = 0;
+        m_uiNothExitDoorGUID  = 0;
+        m_uiHeigEntryDoorGUID = 0;
+        m_uiHeigExitDoorGUID  = 0;
+        m_uiLoathebDoorGUID   = 0;
+
+        m_uiKelthuzadDoorGUID = 0;
     }
 
     void OnCreatureCreate(Creature* pCreature)
     {
+        switch(pCreature->GetEntry())
+        {
+            case NPC_ANUB_REKHAN:
+                m_uiAnubRekhanGUID = pCreature->GetGUID();
+                break;
+            case NPC_FAERLINA:
+                m_uiFaerlinanGUID = pCreature->GetGUID();
+                break;
+            case NPC_THADDIUS:
+                m_uiThaddiusGUID = pCreature->GetGUID();
+                break;
+            case NPC_STALAGG:
+                m_uiStalaggGUID = pCreature->GetGUID();
+                break;
+            case NPC_FEUGEN:
+                m_uiFeugenGUID = pCreature->GetGUID();
+                break;
+            case NPC_ZELIEK:
+                m_uiZeliekGUID = pCreature->GetGUID();
+                break;
+            case NPC_THANE:
+                m_uiThaneGUID = pCreature->GetGUID();
+                break;
+            case NPC_BLAUMEUX:
+                m_uiBlaumeuxGUID = pCreature->GetGUID();
+                break;
+            case NPC_RIVENDARE:
+                m_uiRivendareGUID = pCreature->GetGUID();
+                break;
+        }
     }
 
     void OnObjectCreate(GameObject* pGo)
     {
+        switch(pGo->GetEntry())
+        {
+            case GO_ARAC_ANUB_GATE:
+                m_uiAnubGateGUID = pGo->GetGUID();
+                if (m_auiEncounter[4] == DONE)
+                    pGo->SetGoState(GO_STATE_ACTIVE);
+                break;
+            case GO_ARAC_ANUB_DOOR:
+                m_uiAnubDoorGUID = pGo->GetGUID();
+                if (m_auiEncounter[4] == DONE)
+                    pGo->SetGoState(GO_STATE_ACTIVE);
+                break;
+            //case GO_ARAC_FAER_WEB:            = pGo->GetGUID(); break;
+            //case GO_ARAC_DOOD_DOOR_2:         = pGo->GetGUID(); break;
+            case GO_ARAC_FAER_DOOR:
+                m_uiFaerDoorGUID = pGo->GetGUID();
+                if (m_auiEncounter[5] == DONE)
+                    pGo->SetGoState(GO_STATE_ACTIVE);
+                break;
+            case GO_ARAC_MAEX_OUTER_DOOR:
+                m_uiMaexOuterGUID = pGo->GetGUID();
+                if (m_auiEncounter[5] == DONE)
+                    pGo->SetGoState(GO_STATE_ACTIVE);
+                break;
+            case GO_ARAC_MAEX_INNER_DOOR:
+                m_uiMaexInnerGUID = pGo->GetGUID();
+                break;
+            case GO_ARAC_EYE_RAMP:
+                m_uiAracEyeRampGUID = pGo->GetGUID();
+                if (m_auiEncounter[6] == DONE)
+                    pGo->SetGoState(GO_STATE_ACTIVE);
+                break;
+            case GO_ARAC_PORTAL:
+                m_uiAracPortalGUID = pGo->GetGUID();
+                break;
+
+            //case GO_PLAG_SLIME01_DOOR:        = pGo->GetGUID(); break;
+            //case GO_PLAG_SLIME02_DOOR:        = pGo->GetGUID(); break;
+            case GO_PLAG_NOTH_ENTRY_DOOR:
+                m_uiNothEntryDoorGUID = pGo->GetGUID();
+                break;
+            case GO_PLAG_NOTH_EXIT_DOOR:
+                m_uiNothExitDoorGUID = pGo->GetGUID();
+                if (m_auiEncounter[10] == DONE)
+                    pGo->SetGoState(GO_STATE_ACTIVE);
+                break;
+            case GO_PLAG_HEIG_ENTRY_DOOR:
+                m_uiHeigEntryDoorGUID = pGo->GetGUID();
+                if (m_auiEncounter[10] == DONE)
+                    pGo->SetGoState(GO_STATE_ACTIVE);
+                break;
+            case GO_PLAG_HEIG_EXIT_DOOR:
+                m_uiHeigExitDoorGUID = pGo->GetGUID();
+                if (m_auiEncounter[11] == DONE)
+                    pGo->SetGoState(GO_STATE_ACTIVE);
+                break;
+            case GO_PLAG_LOAT_DOOR:
+                m_uiLoathebDoorGUID = pGo->GetGUID();
+                if (m_auiEncounter[11] == DONE)
+                    pGo->SetGoState(GO_STATE_ACTIVE);
+                break;
+            case GO_PLAG_EYE_RAMP:
+                m_uiPlagEyeRampGUID = pGo->GetGUID();
+                if (m_auiEncounter[12] == DONE)
+                    pGo->SetGoState(GO_STATE_ACTIVE);
+                break;
+            case GO_PLAG_PORTAL:
+                m_uiPlagPortalGUID = pGo->GetGUID();
+                break;
+
+            case GO_MILI_GOTH_ENTRY_GATE:
+                m_uiGothikEntryDoorGUID = pGo->GetGUID();
+                if (m_auiEncounter[7] == DONE)
+                    pGo->SetGoState(GO_STATE_ACTIVE);
+                break;
+            case GO_MILI_GOTH_EXIT_GATE:
+                m_uiGothikExitDoorGUID = pGo->GetGUID();
+                if (m_auiEncounter[8] == DONE)
+                    pGo->SetGoState(GO_STATE_ACTIVE);
+                break;
+            case GO_MILI_GOTH_COMBAT_GATE:
+                m_uiGothCombatGateGUID = pGo->GetGUID();
+                break;
+            case GO_MILI_HORSEMEN_DOOR:
+                m_uiHorsemenDoorGUID  = pGo->GetGUID();
+                if (m_auiEncounter[8] == DONE)
+                    pGo->SetGoState(GO_STATE_ACTIVE);
+                break;
+            case GO_MILI_EYE_RAMP:
+                m_uiMiliEyeRampGUID = pGo->GetGUID();
+                if (m_auiEncounter[9] == DONE)
+                    pGo->SetGoState(GO_STATE_ACTIVE);
+                break;
+            case GO_MILI_PORTAL:
+                m_uiMiliPortalGUID = pGo->GetGUID();
+                break;
+
+            case GO_CHEST_HORSEMEN_NORM:
+                m_uiHorsemenChestNGUID = pGo->GetGUID();
+                break;
+            //case GO_CHEST_HORSEMEN_HERO:      = pGo->GetGUID(); break;
+
+            case GO_CONS_PATH_EXIT_DOOR:
+                m_uiPathExitDoorGUID = pGo->GetGUID();
+                if (m_auiEncounter[0] == DONE)
+                    pGo->SetGoState(GO_STATE_ACTIVE);
+                break;
+            case GO_CONS_GLUT_EXIT_DOOR:
+                m_uiGlutExitDoorGUID = pGo->GetGUID();
+                if (m_auiEncounter[2] == DONE)
+                    pGo->SetGoState(GO_STATE_ACTIVE);
+                break;
+            case GO_CONS_THAD_DOOR:
+                m_uiThadDoorGUID = pGo->GetGUID();
+                if (m_auiEncounter[2] == DONE)
+                    pGo->SetGoState(GO_STATE_ACTIVE);
+                break;
+            case GO_CONS_EYE_RAMP:
+                m_uiConsEyeRampGUID = pGo->GetGUID();
+                if (m_auiEncounter[3] == DONE)
+                    pGo->SetGoState(GO_STATE_ACTIVE);
+                break;
+            case GO_CONS_PORTAL:
+                m_uiConsPortalGUID = pGo->GetGUID();
+                break;
+
+            case GO_KELTHUZAD_WATERFALL_DOOR:
+                m_uiKelthuzadDoorGUID = pGo->GetGUID();
+                if (m_auiEncounter[13] == DONE)
+                    pGo->SetGoState(GO_STATE_ACTIVE);
+                break;
+        }
     }
 
     void SetData(uint32 uiType, uint32 uiData)
     {
+        switch(uiType)
+        {
+            case TYPE_PATCHWERK:
+                m_auiEncounter[0] = uiData;
+                if (uiData == DONE)
+                    DoorControl(m_uiPathExitDoorGUID, uiData);
+                break;
+            case TYPE_GROBBULUS:
+                m_auiEncounter[1] = uiData;
+                break;
+            case TYPE_GLUTH:
+                m_auiEncounter[2] = uiData;
+                if (uiData == DONE)
+                {
+                    DoorControl(m_uiGlutExitDoorGUID, uiData);
+                    DoorControl(m_uiThadDoorGUID, uiData);
+                }
+                break;
+            case TYPE_THADDIUS:
+                m_auiEncounter[3] = uiData;
+                DoorControl(m_uiThadDoorGUID, uiData);
+                if (uiData == DONE)
+                {
+                    ActiveRamp(m_uiConsEyeRampGUID);
+                    if (GameObject* pPortal = instance->GetGameObject(m_uiConsPortalGUID))
+                        if (pPortal && !pPortal->isSpawned())
+                            pPortal->SetRespawnTime(350000000);
+                }
+                break;
+
+            case TYPE_ANUB_REKHAN:
+                m_auiEncounter[4] = uiData;
+                DoorControl(m_uiAnubDoorGUID, uiData);
+                if (uiData == DONE)
+                    DoorControl(m_uiAnubGateGUID, uiData);
+                break;
+            case TYPE_FAERLINA:
+                m_auiEncounter[5] = uiData;
+                if (uiData == DONE)
+                {
+                    DoorControl(m_uiFaerDoorGUID, uiData);
+                    DoorControl(m_uiMaexOuterGUID, uiData);
+                }
+                break;
+            case TYPE_MAEXXNA:
+                m_auiEncounter[6] = uiData;
+                DoorControl(m_uiMaexOuterGUID, uiData);
+                DoorControl(m_uiMaexInnerGUID, uiData);
+                if (uiData == DONE)
+                {
+                    ActiveRamp(m_uiAracEyeRampGUID);
+                    if (GameObject* pPortal = instance->GetGameObject(m_uiAracPortalGUID))
+                        if (pPortal && !pPortal->isSpawned())
+                            pPortal->SetRespawnTime(350000000);
+                }
+                break;
+
+            case TYPE_RAZUVIOUS:
+                m_auiEncounter[7] = uiData;
+                if (uiData == DONE)
+                     DoorControl(m_uiGothikEntryDoorGUID, uiData);
+                break;
+            case TYPE_GOTHIK:
+                m_auiEncounter[8] = uiData;
+                if (uiData == DONE)
+                {
+                     DoorControl(m_uiGothikExitDoorGUID, uiData);
+                     DoorControl(m_uiHorsemenDoorGUID, uiData);
+                }
+                break;
+            case TYPE_FOUR_HORSEMEN:
+                m_auiEncounter[9] = uiData;
+                DoorControl(m_uiHorsemenDoorGUID, uiData);
+                if (uiData == DONE)
+                {
+                    ActiveRamp(m_uiMiliEyeRampGUID);
+                    if (GameObject* pPortal = instance->GetGameObject(m_uiMiliPortalGUID))
+                        if (pPortal && !pPortal->isSpawned())
+                            pPortal->SetRespawnTime(350000000);
+                    if (GameObject* pChest = instance->GetGameObject(m_uiHorsemenChestNGUID)) // how about heroic
+                        if (pChest && !pChest->isSpawned())
+                            pChest->SetRespawnTime(350000000);
+                }
+                break;
+
+            case TYPE_NOTH:
+                m_auiEncounter[10] = uiData;
+                DoorControl(m_uiNothEntryDoorGUID, uiData);
+                if (uiData == DONE)
+                {
+                     DoorControl(m_uiNothExitDoorGUID, uiData);
+                     DoorControl(m_uiHeigEntryDoorGUID, uiData);
+                }
+                break;
+            case TYPE_HEIGAN:
+                m_auiEncounter[11] = uiData;
+                DoorControl(m_uiHeigEntryDoorGUID, uiData);
+                if (uiData == DONE)
+                {
+                     DoorControl(m_uiHeigExitDoorGUID, uiData);
+                     DoorControl(m_uiLoathebDoorGUID, uiData);
+                }
+                break;
+            case TYPE_LOATHEB:
+                m_auiEncounter[12] = uiData;
+                DoorControl(m_uiLoathebDoorGUID, uiData);
+                if (uiData == DONE)
+                {
+                    ActiveRamp(m_uiPlagEyeRampGUID);
+                    if (GameObject* pPortal = instance->GetGameObject(m_uiPlagPortalGUID))
+                        if (pPortal && !pPortal->isSpawned())
+                            pPortal->SetRespawnTime(350000000);
+                }
+                break;
+
+            case TYPE_SAPPHIRON:
+                m_auiEncounter[13] = uiData;
+                if (uiData == DONE)
+                    ActiveRamp(m_uiKelthuzadDoorGUID);
+                break;
+            case TYPE_KELTHUZAD:
+                m_auiEncounter[14] = uiData;
+                break;
+        }
+
+        if (uiData == DONE)
+        {
+            OUT_SAVE_INST_DATA;
+
+            std::ostringstream saveStream;
+            saveStream << m_auiEncounter[0] << " " << m_auiEncounter[1] << " " << m_auiEncounter[2] << " "
+                << m_auiEncounter[3] << " " << m_auiEncounter[4] << " " << m_auiEncounter[5] << " "
+                << m_auiEncounter[6] << " " << m_auiEncounter[7] << " " << m_auiEncounter[8] << " "
+                << m_auiEncounter[9] << " " << m_auiEncounter[10] << " " << m_auiEncounter[11] << " "
+                << m_auiEncounter[12] << " " << m_auiEncounter[13] << " " << m_auiEncounter[14];
+
+            strInstData = saveStream.str();
+
+            SaveToDB();
+            OUT_SAVE_INST_DATA_COMPLETE;
+        }
     }
 
+    const char* Save()
+    {
+        return strInstData.c_str();
+    }
+
     uint32 GetData(uint32 uiType)
     {
+        switch(uiType)
+        {
+            case TYPE_PATCHWERK:
+                return m_auiEncounter[0];
+            case TYPE_GROBBULUS:
+                return m_auiEncounter[1];
+            case TYPE_GLUTH:
+                return m_auiEncounter[2];
+            case TYPE_THADDIUS:
+                return m_auiEncounter[3];
+            case TYPE_ANUB_REKHAN:
+                return m_auiEncounter[4];
+            case TYPE_FAERLINA:
+                return m_auiEncounter[5];
+            case TYPE_MAEXXNA:
+                return m_auiEncounter[6];
+            case TYPE_RAZUVIOUS:
+                return m_auiEncounter[7];
+            case TYPE_GOTHIK:
+                return m_auiEncounter[8];
+            case TYPE_FOUR_HORSEMEN:
+                return m_auiEncounter[9];
+            case TYPE_NOTH:
+                return m_auiEncounter[10];
+            case TYPE_HEIGAN:
+                return m_auiEncounter[11];
+            case TYPE_LOATHEB:
+                return m_auiEncounter[12];
+            case TYPE_SAPPHIRON:
+                return m_auiEncounter[13];
+            case TYPE_KELTHUZAD:
+                return m_auiEncounter[14];
+        }
         return 0;
     }
 
     uint64 GetData64(uint32 uiData)
     {
+        switch(uiData)
+        {
+            case DATA_ANUB_REKHAN:
+                return m_uiAnubRekhanGUID;
+            case DATA_FAERLINA:
+                return m_uiFaerlinanGUID;
+            case DATA_GOTHIK_GATE:
+                return m_uiGothCombatGateGUID;
+            case DATA_THADDIUS:
+                return m_uiThaddiusGUID;
+            case DATA_STALAGG:
+                return m_uiStalaggGUID;
+            case DATA_FEUGEN:
+                return m_uiFeugenGUID;
+
+            case DATA_ZELIEK:
+                return m_uiZeliekGUID;
+            case DATA_KORTHAZZ:
+                return m_uiThaneGUID;
+            case DATA_BLAUMEUX:
+                return m_uiBlaumeuxGUID;
+            case DATA_RIVENDARE:
+                return m_uiRivendareGUID;
+        }
         return 0;
     }
+
+    void Load(const char* in)
+    {
+        if (!in)
+        {
+            OUT_LOAD_INST_DATA_FAIL;
+            return;
+        }
+
+        OUT_LOAD_INST_DATA(in);
+
+        std::istringstream loadStream(in);
+        loadStream >> m_auiEncounter[0] >> m_auiEncounter[1] >> m_auiEncounter[2] >> m_auiEncounter[3]
+            >> m_auiEncounter[4] >> m_auiEncounter[5] >> m_auiEncounter[6] >> m_auiEncounter[7]
+            >> m_auiEncounter[8] >> m_auiEncounter[9] >> m_auiEncounter[10] >> m_auiEncounter[11]
+            >> m_auiEncounter[12] >> m_auiEncounter[13] >> m_auiEncounter[14];
+
+        for(uint8 i = 0; i < MAX_ENCOUNTER; ++i)
+        {
+            if (m_auiEncounter[i] == IN_PROGRESS)
+                m_auiEncounter[i] = NOT_STARTED;
+        }
+
+        OUT_LOAD_INST_DATA_COMPLETE;
+    }
+
+    void DoorControl(uint64 uiDoor, uint32 uiData)
+    {
+        if (GameObject* pDoors = instance->GetGameObject(uiDoor))
+        {
+            if(uiData == IN_PROGRESS)
+                pDoors->SetGoState(GO_STATE_READY);
+            else
+                pDoors->SetGoState(GO_STATE_ACTIVE);
+        }
+    }
+    void ActiveRamp(uint64 uiRamp)
+    {
+        if (GameObject* pRamp = instance->GetGameObject(uiRamp))
+            pRamp->SetGoState(GO_STATE_ACTIVE);
+    }
 };
 
 InstanceData* GetInstanceData_instance_naxxramas(Map* pMap)
@@ -108,9 +582,9 @@
 
 void AddSC_instance_naxxramas()
 {
-    Script* pNewScript;
-    pNewScript = new Script;
-    pNewScript->Name = "instance_naxxramas";
-    pNewScript->GetInstanceData = &GetInstanceData_instance_naxxramas;
-    pNewScript->RegisterSelf();
+    Script *newscript;
+    newscript = new Script;
+    newscript->Name = "instance_naxxramas";
+    newscript->GetInstanceData = GetInstanceData_instance_naxxramas;
+    newscript->RegisterSelf();
 }
